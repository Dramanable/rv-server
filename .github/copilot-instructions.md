`````instructions
````instructions
# ü§ñ GitHub Copilot Instructions pour Clean Architecture + NestJS

## üéØ **Context du Projet**

Vous travaillez sur une **application enterprise NestJS** impl√©mentant la **Clean Architecture de Robert C. Martin (Uncle Bob)** avec une approche **TDD rigoureuse**, les **principes SOLID**, et les **meilleures pratiques TypeScript** strictes. L'application est **production-ready** avec s√©curit√©, i18n, et patterns enterprise.

## üö® **R√àGLE CRITIQUE : APPLICATION PROFESSIONNELLE D'ENTREPRISE**

**‚ö†Ô∏è R√àGLE NON-N√âGOCIABLE** : Cette application est une **solution d'entreprise professionnelle**, pas un blog ou prototype. CHAQUE ligne de code DOIT respecter les standards d'entreprise :

### üìä **LOGGING OBLIGATOIRE PARTOUT**

**TOUJOURS inclure le logging dans CHAQUE couche :**

```typescript
// ‚úÖ OBLIGATOIRE - Use Case avec logging complet
export class CreateSkillUseCase {
  constructor(
    private readonly skillRepository: ISkillRepository,
    private readonly logger: ILogger, // ‚ö†Ô∏è OBLIGATOIRE
    private readonly i18n: I18nService, // ‚ö†Ô∏è OBLIGATOIRE
  ) {}

  async execute(request: CreateSkillRequest): Promise<CreateSkillResponse> {
    this.logger.info('Creating new skill', {
      businessId: request.businessId,
      skillName: request.name,
      requestingUserId: request.requestingUserId,
      correlationId: request.correlationId, // ‚ö†Ô∏è OBLIGATOIRE
    });

    try {
      const skill = Skill.create(/* ... */);
      const savedSkill = await this.skillRepository.save(skill);

      this.logger.info('Skill created successfully', {
        skillId: savedSkill.getId(),
        businessId: request.businessId,
        correlationId: request.correlationId,
      });

      return CreateSkillResponse.fromSkill(savedSkill);
    } catch (error) {
      this.logger.error('Failed to create skill', {
        error: error.message,
        businessId: request.businessId,
        correlationId: request.correlationId,
      });
      throw error;
    }
  }
}
```

### üåê **I18N OBLIGATOIRE POUR TOUS LES MESSAGES**

**JAMAIS de texte hardcod√© :**

```typescript
// ‚ùå INTERDIT - Messages hardcod√©s
throw new Error('Skill name is required');

// ‚úÖ OBLIGATOIRE - Messages i18n
throw new SkillValidationError(
  this.i18n.translate('skill.validation.nameRequired'),
  'SKILL_NAME_REQUIRED'
);
```

### üîç **CONTEXTE ET TRA√áABILIT√â OBLIGATOIRES**

**Chaque requ√™te DOIT avoir :**
- **correlationId** : UUID unique pour tracer la requ√™te
- **requestingUserId** : Qui fait l'action
- **businessContext** : Dans quel contexte business
- **operationMetadata** : M√©tadonn√©es de l'op√©ration

```typescript
// ‚úÖ OBLIGATOIRE - Interface de requ√™te avec contexte
export interface CreateSkillRequest {
  // Business data
  readonly businessId: string;
  readonly name: string;
  readonly category: string;
  readonly description: string;
  readonly isCritical: boolean;

  // ‚ö†Ô∏è CONTEXTE OBLIGATOIRE
  readonly requestingUserId: string; // Qui fait l'action
  readonly correlationId: string;    // Tra√ßabilit√© unique
  readonly clientIp?: string;        // IP client (s√©curit√©)
  readonly userAgent?: string;       // User agent
  readonly timestamp: Date;          // Horodatage pr√©cis
}
```

## üê≥ **ENVIRONNEMENT DOCKER EXCLUSIF - R√àGLE ABSOLUE**

### üõ†Ô∏è **R√àGLE CRITIQUE NON-N√âGOCIABLE : TOUT TOURNE SUR DOCKER**

**‚ö†Ô∏è INTERDICTION ABSOLUE D'EX√âCUTER DES COMMANDES SUR L'HOST**

L'application **TOURNE EXCLUSIVEMENT SUR DOCKER** avec Docker Compose. **AUCUNE** commande ne doit √™tre ex√©cut√©e directement sur la machine host.

**üö® NOUVELLE R√àGLE CRITIQUE** : Toute commande npm, node, tsc, lint, test, ou migration DOIT s'ex√©cuter dans le container Docker.

#### **‚úÖ COMMANDES OBLIGATOIRES - TOUJOURS DOCKER**

```bash
# ‚úÖ OBLIGATOIRE - Tous les tests
docker compose exec app npm test
docker compose exec app npm run test:unit
docker compose exec app npm run test:cov

# ‚úÖ OBLIGATOIRE - Lint et formatage
docker compose exec app npm run lint
docker compose exec app npm run lint -- --fix
docker compose exec app npm run format

# ‚úÖ OBLIGATOIRE - Build et compilation
docker compose exec app npm run build
docker compose exec app npx tsc --noEmit

# ‚úÖ OBLIGATOIRE - Migrations (CRITIQUE !)
docker compose exec app npm run migration:run
docker compose exec app npm run migration:revert
docker compose exec app npm run migration:generate -- -n NameOfMigration

# ‚úÖ OBLIGATOIRE - Installation d√©pendances
docker compose exec app npm install package-name
docker compose exec app npm ci

# ‚úÖ OBLIGATOIRE - D√©veloppement
docker compose exec app npm run start:dev
```

#### **üö® WORKFLOW INSTALLATION D√âPENDANCES OBLIGATOIRE**

**‚ö†Ô∏è R√àGLE CRITIQUE** : Pour √©viter les probl√®mes de cache Docker et compatibilit√© :

```bash
# 1Ô∏è‚É£ Installer dans le container
docker compose exec app npm install nouvelle-dependance

# 2Ô∏è‚É£ OBLIGATOIRE : Supprimer le container
docker compose down app

# 3Ô∏è‚É£ OBLIGATOIRE : Reconstruire sans cache
docker compose build --no-cache app

# 4Ô∏è‚É£ Red√©marrer avec nouvelle image
docker compose up -d app

# 5Ô∏è‚É£ V√©rifier d√©marrage
docker compose logs app --tail=20
```

#### **‚ùå INTERDICTIONS ABSOLUES - COMMANDES HOST**

- ‚ùå **JAMAIS** `npm run start:dev` directement
- ‚ùå **JAMAIS** `npm test` sur l'host
- ‚ùå **JAMAIS** `npm run lint` sur l'host
- ‚ùå **JAMAIS** `npm run build` sur l'host
- ‚ùå **JAMAIS** `npm run migration:run` sur l'host
- ‚ùå **JAMAIS** `npx tsc` sur l'host
- ‚ùå **JAMAIS** installer PostgreSQL/Redis/MongoDB localement

## üóÑÔ∏è **R√àGLE CRITIQUE : MIGRATIONS TYPEORM ET DONN√âES EXISTANTES**

### üéØ **R√àGLE FONDAMENTALE NON-N√âGOCIABLE : PR√âSERVER LES DONN√âES EXISTANTES**

**‚ö†Ô∏è R√àGLE CRITIQUE** : Toute migration TypeORM DOIT imp√©rativement tenir compte des donn√©es d√©j√† pr√©sentes en base de donn√©es. Cette r√®gle est **NON-N√âGOCIABLE** pour √©viter la corruption de donn√©es et les pannes en production.

#### **üìã PRINCIPE FONDAMENTAL : SAFETY-FIRST MIGRATIONS**

**TOUJOURS se demander avant chaque migration :**
1. **Y a-t-il d√©j√† des donn√©es** dans cette table ?
2. **Comment pr√©server** l'int√©grit√© des donn√©es existantes ?
3. **Les contraintes ajout√©es** sont-elles compatibles avec les donn√©es actuelles ?
4. **Les colonnes supprim√©es** contiennent-elles des donn√©es critiques ?

#### **‚úÖ PATTERNS OBLIGATOIRES SELON LE TYPE DE MIGRATION**

##### **üÜï AJOUT DE COLONNE - Gestion des Valeurs par D√©faut**

```typescript
// ‚úÖ OBLIGATOIRE - Colonne nullable ou avec valeur par d√©faut
export class AddPricingConfigToServices implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ CORRECT - V√©rifier l'existence avant ajout
    const columnExists = await queryRunner.hasColumn(`${schema}.services`, 'pricing_config');

    if (!columnExists) {
      // ‚úÖ CORRECT - Colonne avec DEFAULT pour donn√©es existantes
      await queryRunner.query(`
        ALTER TABLE "${schema}"."services"
        ADD COLUMN "pricing_config" jsonb
        DEFAULT '{"type":"FIXED","basePrice":{"amount":0,"currency":"EUR"}}'::jsonb
      `);

      // ‚úÖ CORRECT - Mettre √† jour les donn√©es existantes si n√©cessaire
      await queryRunner.query(`
        UPDATE "${schema}"."services"
        SET "pricing_config" = '{"type":"FIXED","basePrice":{"amount":50,"currency":"EUR"}}'::jsonb
        WHERE "pricing_config" IS NULL AND "is_active" = true
      `);
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ CORRECT - V√©rifier avant suppression
    const columnExists = await queryRunner.hasColumn(`${schema}.services`, 'pricing_config');

    if (columnExists) {
      // ‚ö†Ô∏è ATTENTION - Sauvegarder les donn√©es critiques avant suppression
      await queryRunner.query(`
        -- Optionnel : Sauvegarder les donn√©es dans une table temporaire
        CREATE TABLE IF NOT EXISTS "${schema}"."services_pricing_backup" AS
        SELECT id, pricing_config FROM "${schema}"."services"
        WHERE pricing_config IS NOT NULL
      `);

      await queryRunner.query(`
        ALTER TABLE "${schema}"."services" DROP COLUMN IF EXISTS "pricing_config"
      `);
    }
  }
}
```

##### **üîß MODIFICATION DE COLONNE - Gestion des Types et Contraintes**

```typescript
// ‚úÖ OBLIGATOIRE - Transformation s√©curis√©e des donn√©es
export class UpdateStatusEnumInServices implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ √âTAPE 1 - V√©rifier les donn√©es existantes
    const existingData = await queryRunner.query(`
      SELECT DISTINCT status FROM "${schema}"."services"
    `);

    console.log('Statuts existants avant migration:', existingData);

    // ‚úÖ √âTAPE 2 - Ajouter une colonne temporaire avec nouveau type
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services"
      ADD COLUMN "status_new" VARCHAR(20)
    `);

    // ‚úÖ √âTAPE 3 - Migrer les donn√©es avec mapping appropri√©
    await queryRunner.query(`
      UPDATE "${schema}"."services"
      SET "status_new" = CASE
        WHEN status = 'active' THEN 'ACTIVE'
        WHEN status = 'inactive' THEN 'INACTIVE'
        WHEN status = 'draft' THEN 'DRAFT'
        ELSE 'DRAFT' -- Valeur par d√©faut pour donn√©es inconnues
      END
    `);

    // ‚úÖ √âTAPE 4 - Supprimer ancienne colonne et renommer
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services" DROP COLUMN "status"
    `);

    await queryRunner.query(`
      ALTER TABLE "${schema}"."services"
      RENAME COLUMN "status_new" TO "status"
    `);

    // ‚úÖ √âTAPE 5 - Ajouter contraintes apr√®s transformation
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services"
      ALTER COLUMN "status" SET NOT NULL
    `);
  }
}
```

##### **üóëÔ∏è SUPPRESSION DE COLONNE - Sauvegarde Obligatoire**

```typescript
// ‚úÖ OBLIGATOIRE - Sauvegarde avant suppression
export class RemoveDeprecatedColumnsFromServices implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ √âTAPE 1 - V√©rifier s'il y a des donn√©es dans la colonne
    const dataCount = await queryRunner.query(`
      SELECT COUNT(*) as count FROM "${schema}"."services"
      WHERE "deprecated_field" IS NOT NULL
    `);

    if (dataCount[0]?.count > 0) {
      // ‚úÖ √âTAPE 2 - Cr√©er table de sauvegarde
      await queryRunner.query(`
        CREATE TABLE "${schema}"."services_deprecated_backup" AS
        SELECT id, deprecated_field, created_at
        FROM "${schema}"."services"
        WHERE deprecated_field IS NOT NULL
      `);

      console.log(`Sauvegarde de ${dataCount[0].count} enregistrements dans services_deprecated_backup`);
    }

    // ‚úÖ √âTAPE 3 - Supprimer la colonne
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services" DROP COLUMN IF EXISTS "deprecated_field"
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ √âTAPE 1 - Recr√©er la colonne
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services"
      ADD COLUMN "deprecated_field" VARCHAR(255)
    `);

    // ‚úÖ √âTAPE 2 - Restaurer les donn√©es depuis la sauvegarde
    const backupExists = await queryRunner.hasTable(`${schema}.services_deprecated_backup`);

    if (backupExists) {
      await queryRunner.query(`
        UPDATE "${schema}"."services"
        SET "deprecated_field" = backup."deprecated_field"
        FROM "${schema}"."services_deprecated_backup" backup
        WHERE "${schema}"."services".id = backup.id
      `);
    }
  }
}
```

#### **üö® WORKFLOW OBLIGATOIRE AVANT CHAQUE MIGRATION**

##### **1Ô∏è‚É£ AUDIT DES DONN√âES EXISTANTES (OBLIGATOIRE)**

```bash
# ‚úÖ OBLIGATOIRE - Se connecter √† la base et analyser les donn√©es
docker compose exec postgres-dev psql -U postgres -d appointment_system

-- V√©rifier la structure actuelle
\dt+ schema_name.*

-- Analyser les donn√©es dans la table concern√©e
SELECT COUNT(*), column_name FROM table_name GROUP BY column_name;
SELECT DISTINCT column_name FROM table_name;
SELECT * FROM table_name LIMIT 10;
```

##### **2Ô∏è‚É£ PLAN DE MIGRATION S√âCURIS√â**

```typescript
// ‚úÖ OBLIGATOIRE - Documenter le plan dans la migration
export class ExampleMigration implements MigrationInterface {
  name = 'ExampleMigration';

  /**
   * PLAN DE MIGRATION S√âCURIS√â
   *
   * üéØ OBJECTIF : [D√©crire l'objectif de la migration]
   *
   * üìä DONN√âES EXISTANTES :
   * - Table "services" contient 150 enregistrements
   * - Colonne "status" : 120 'active', 25 'inactive', 5 'draft'
   * - Aucune valeur NULL dans "status"
   *
   * üõ°Ô∏è MESURES DE S√âCURIT√â :
   * - V√©rification existence colonne avant modification
   * - Sauvegarde donn√©es critiques dans table temporaire
   * - Transformation progressive avec mapping explicite
   * - Rollback complet possible via m√©thode down()
   *
   * ‚ö†Ô∏è RISQUES IDENTIFI√âS :
   * - Perte de donn√©es si mapping incorrect
   * - Contraintes NOT NULL sur donn√©es existantes
   * - Temps d'ex√©cution sur tables volumineuses
   *
   * ‚úÖ TESTS EFFECTU√âS :
   * - Migration test√©e sur copie de base de d√©veloppement
   * - Rollback v√©rifi√© et fonctionnel
   * - Performances acceptables (<5 secondes)
   */
}
```

##### **3Ô∏è‚É£ TESTS OBLIGATOIRES EN D√âVELOPPEMENT**

```bash
# ‚úÖ WORKFLOW OBLIGATOIRE - Tester la migration
# 1. Sauvegarder la base actuelle
docker compose exec postgres-dev pg_dump -U postgres appointment_system > backup_pre_migration.sql

# 2. Appliquer la migration
docker compose exec app npm run migration:run

# 3. V√©rifier les donn√©es apr√®s migration
docker compose exec postgres-dev psql -U postgres -d appointment_system -c "SELECT COUNT(*) FROM services;"

# 4. Tester le rollback
docker compose exec app npm run migration:revert

# 5. V√©rifier que les donn√©es sont restaur√©es
docker compose exec postgres-dev psql -U postgres -d appointment_system -c "SELECT COUNT(*) FROM services;"

# 6. Re-appliquer si le test de rollback r√©ussit
docker compose exec app npm run migration:run
```

#### **‚ùå INTERDICTIONS ABSOLUES - MIGRATIONS DESTRUCTRICES**

- ‚ùå **JAMAIS** `DROP COLUMN` sans sauvegarde des donn√©es
- ‚ùå **JAMAIS** `ALTER COLUMN ... NOT NULL` sans v√©rifier les donn√©es existantes
- ‚ùå **JAMAIS** `DROP TABLE` sans export complet des donn√©es
- ‚ùå **JAMAIS** de migration sans plan de rollback test√©
- ‚ùå **JAMAIS** de transformation de type destructrice
- ‚ùå **JAMAIS** de migration sans v√©rification pr√©alable des donn√©es
- ‚ùå **JAMAIS** ignorer les warnings sur les contraintes

#### **üéØ CHECKLIST OBLIGATOIRE POUR CHAQUE MIGRATION**

- [ ] ‚úÖ **Analyse des donn√©es existantes** effectu√©e
- [ ] ‚úÖ **Plan de migration** document√© dans le fichier
- [ ] ‚úÖ **V√©rifications d'existence** avant modifications
- [ ] ‚úÖ **Valeurs par d√©faut** appropri√©es pour nouvelles colonnes
- [ ] ‚úÖ **Sauvegarde automatique** des donn√©es critiques
- [ ] ‚úÖ **Transformation progressive** pour modifications de type
- [ ] ‚úÖ **M√©thode down()** compl√®te et test√©e
- [ ] ‚úÖ **Tests de migration/rollback** en d√©veloppement
- [ ] ‚úÖ **Performance acceptable** sur donn√©es volumineuses
- [ ] ‚úÖ **Documentation des risques** identifi√©s et mitig√©s

#### **üìä EXEMPLES CONCRETS PAR CAS D'USAGE**

##### **Cas 1 : Ajout de colonne obligatoire sur table peupl√©e**
```sql
-- ‚ùå INTERDIT - Causera des erreurs sur donn√©es existantes
ALTER TABLE services ADD COLUMN required_field VARCHAR(50) NOT NULL;

-- ‚úÖ CORRECT - Progression en 3 √©tapes
-- √âtape 1 : Ajouter colonne nullable avec d√©faut
ALTER TABLE services ADD COLUMN required_field VARCHAR(50) DEFAULT 'DEFAULT_VALUE';

-- √âtape 2 : Mettre √† jour les donn√©es existantes
UPDATE services SET required_field = 'APPROPRIATE_VALUE' WHERE required_field IS NULL;

-- √âtape 3 : Ajouter contrainte NOT NULL
ALTER TABLE services ALTER COLUMN required_field SET NOT NULL;
```

##### **Cas 2 : Changement de type avec donn√©es existantes**
```sql
-- ‚ùå INTERDIT - Perte de donn√©es garantie
ALTER TABLE services ALTER COLUMN price TYPE INTEGER;

-- ‚úÖ CORRECT - Colonne temporaire et migration
ALTER TABLE services ADD COLUMN price_new INTEGER;
UPDATE services SET price_new = CAST(price AS INTEGER) WHERE price ~ '^[0-9]+$';
UPDATE services SET price_new = 0 WHERE price_new IS NULL; -- D√©faut s√©curis√©
ALTER TABLE services DROP COLUMN price;
ALTER TABLE services RENAME COLUMN price_new TO price;
```

#### **üö® SANCTIONS POUR NON-RESPECT**

Le non-respect de cette r√®gle entra√Æne :
- **Blocage imm√©diat** de la migration en production
- **Corruption potentielle** des donn√©es critiques
- **Rollback d'urgence** et investigation compl√®te
- **Review obligatoire** de toutes les migrations futures
- **Formation suppl√©mentaire** sur les bonnes pratiques

**Cette r√®gle est CRITIQUE pour la s√©curit√© et l'int√©grit√© des donn√©es !**

### üë§ **TRA√áABILIT√â UTILISATEUR OBLIGATOIRE**

**‚ö†Ô∏è R√àGLE CRITIQUE : Il faut TOUJOURS savoir qui a cr√©√© quoi et qui a mis √† jour quoi**

**CHAQUE entit√© DOIT avoir :**
- **createdBy** : UUID de l'utilisateur qui a cr√©√© l'entit√©
- **updatedBy** : UUID de l'utilisateur qui a fait la derni√®re modification
- **createdAt** : Timestamp de cr√©ation
- **updatedAt** : Timestamp de derni√®re modification

```typescript
// ‚úÖ OBLIGATOIRE - Pattern d'entit√© avec tra√ßabilit√© compl√®te
export class Skill {
  private constructor(
    private readonly _id: string,
    private readonly _businessId: BusinessId,
    private _name: string,
    private _category: string,
    private _description: string,
    private _isActive: boolean,
    private _isCritical: boolean,
    private readonly _createdBy: string,    // ‚ö†Ô∏è OBLIGATOIRE
    private _updatedBy: string,             // ‚ö†Ô∏è OBLIGATOIRE
    private readonly _createdAt: Date,      // ‚ö†Ô∏è OBLIGATOIRE
    private _updatedAt: Date,               // ‚ö†Ô∏è OBLIGATOIRE
  ) {}

  static create(params: {
    businessId: BusinessId;
    name: string;
    category: string;
    description: string;
    isCritical: boolean;
    createdBy: string; // ‚ö†Ô∏è OBLIGATOIRE - UUID de l'utilisateur
  }): Skill {
    const now = new Date();
    return new Skill(
      generateId(),
      params.businessId,
      params.name,
      params.category,
      params.description,
      true, // Actif par d√©faut
      params.isCritical,
      params.createdBy,    // ‚ö†Ô∏è OBLIGATOIRE
      params.createdBy,    // updatedBy = createdBy initialement
      now,                 // createdAt
      now,                 // updatedAt
    );
  }

  update(params: {
    name?: string;
    category?: string;
    description?: string;
    isCritical?: boolean;
    isActive?: boolean;
    updatedBy: string; // ‚ö†Ô∏è OBLIGATOIRE - UUID de l'utilisateur
  }): void {
    if (params.name) this._name = params.name;
    if (params.category) this._category = params.category;
    if (params.description !== undefined) this._description = params.description;
    if (params.isCritical !== undefined) this._isCritical = params.isCritical;
    if (params.isActive !== undefined) this._isActive = params.isActive;

    this._updatedBy = params.updatedBy; // ‚ö†Ô∏è OBLIGATOIRE
    this._updatedAt = new Date();       // ‚ö†Ô∏è OBLIGATOIRE
  }

  // Getters pour tra√ßabilit√©
  getCreatedBy(): string { return this._createdBy; }
  getUpdatedBy(): string { return this._updatedBy; }
  getCreatedAt(): Date { return this._createdAt; }
  getUpdatedAt(): Date { return this._updatedAt; }
}
```

**MIGRATIONS ORM - Pattern obligatoire :**
```typescript
// ‚úÖ OBLIGATOIRE - Colonnes de tra√ßabilit√© dans TOUTES les tables
export class CreateSkillsTable implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: 'skills',
        columns: [
          // Colonnes m√©tier...

          // ‚ö†Ô∏è TRA√áABILIT√â OBLIGATOIRE
          {
            name: 'created_by',
            type: 'uuid',
            isNullable: false,
            comment: 'UUID of user who created this skill',
          },
          {
            name: 'updated_by',
            type: 'uuid',
            isNullable: false,
            comment: 'UUID of user who last updated this skill',
          },
          {
            name: 'created_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
            comment: 'Creation timestamp',
          },
          {
            name: 'updated_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
            onUpdate: 'CURRENT_TIMESTAMP',
            comment: 'Last update timestamp',
          },
        ],
      }),
      true,
    );
  }
}
```

### üîê **AUDIT TRAIL OBLIGATOIRE**

**Toutes les op√©rations CRUD doivent √™tre audit√©es :**

```typescript
// ‚úÖ OBLIGATOIRE - Audit dans les Use Cases
await this.auditService.logOperation({
  operation: 'CREATE_SKILL',
  entityType: 'SKILL',
  entityId: savedSkill.getId(),
  businessId: request.businessId,
  userId: request.requestingUserId,
  correlationId: request.correlationId,
  changes: {
    created: savedSkill.toJSON(),
  },
  timestamp: new Date(),
});
```

### üìã **CHECKLIST OBLIGATOIRE POUR CHAQUE FICHIER**

- [ ] ‚úÖ **Logging** : ILogger inject√© et utilis√©
- [ ] ‚úÖ **I18n** : I18nService inject√©, messages traduits
- [ ] ‚úÖ **Contexte** : correlationId, requestingUserId pr√©sents
- [ ] ‚úÖ **Error Handling** : Erreurs logg√©es avec contexte
- [ ] ‚úÖ **Audit** : Op√©rations critiques audit√©es
- [ ] ‚úÖ **M√©tadonn√©es** : Timestamp, IP, UserAgent captur√©s
- [ ] ‚úÖ **Types stricts** : Aucun `any`, interfaces compl√®tes
- [ ] ‚úÖ **Validation** : Donn√©es valid√©es avec messages i18n

### üö´ **INTERDICTIONS ABSOLUES**

- ‚ùå **JAMAIS** de `console.log()` en production
- ‚ùå **JAMAIS** de messages d'erreur hardcod√©s
- ‚ùå **JAMAIS** d'op√©ration sans logging
- ‚ùå **JAMAIS** de Use Case sans correlationId
- ‚ùå **JAMAIS** d'exception sans contexte de tra√ßabilit√©
- ‚ùå **JAMAIS** de CRUD sans audit trail

## üê≥ **ENVIRONNEMENT DOCKER EXCLUSIF - R√àGLE ABSOLUE**

### ÔøΩ **R√àGLE CRITIQUE NON-N√âGOCIABLE : TOUT TOURNE SUR DOCKER**

**‚ö†Ô∏è INTERDICTION ABSOLUE D'EX√âCUTER DES COMMANDES SUR L'HOST**

L'application **TOURNE EXCLUSIVEMENT SUR DOCKER** avec Docker Compose. **AUCUNE** commande ne doit √™tre ex√©cut√©e directement sur la machine host.

**üéØ POURQUOI DOCKER EXCLUSIF :**
- **üéØ Consistance d'environnement** : M√™me stack partout (dev, staging, prod)
- **üóÑÔ∏è Base de donn√©es int√©gr√©e** : PostgreSQL + Redis dans containers
- **üîß Hot reload activ√©** : D√©veloppement fluide avec volumes mont√©s
- **‚öôÔ∏è Configuration simplifi√©e** : Variables d'environnement centralis√©es
- **üöÄ D√©ploiement reproductible** : Infrastructure as Code
- **üîí Isolation compl√®te** : Pas de pollution de l'environnement host
- **üì¶ D√©pendances ma√Ætris√©es** : Versions exactes dans containers

### **üîß Commandes Docker OBLIGATOIRES - REMPLACEMENTS HOST**

```bash
# üê≥ D√©marrer TOUS les services (App + DB + Redis)
make start
# OU
docker compose up -d

# üìä D√©marrer SEULEMENT les bases de donn√©es
make start-db

# üõë Arr√™ter tous les services
make stop

# üîÑ Red√©marrer les services
make restart

# üìù Voir les logs
make logs

# üßπ Nettoyer volumes et images
make clean

# ‚ö†Ô∏è NOUVEAU - Commandes dans container OBLIGATOIRES
docker compose exec app npm run lint
docker compose exec app npm run test
docker compose exec app npm run build
docker compose exec app npx tsc --noEmit
docker compose exec app npm run migration:run
docker compose exec app npm run migration:revert
```

### **üö® R√àGLE CRITIQUE : INSTALLATION D√âPENDANCES DANS LE CONTAINER**

**‚ö†Ô∏è WORKFLOW OBLIGATOIRE** : Pour √©viter les probl√®mes de compatibilit√© et cache Docker, TOUJOURS installer les d√©pendances depuis le container et supprimer le container avant reconstruction :

```bash
# ‚úÖ WORKFLOW CORRECT - Installation depuis le container
# 1Ô∏è‚É£ Entrer dans le container pour installer la d√©pendance
docker compose exec app npm install nouvelle-dependance

# 2Ô∏è‚É£ OBLIGATOIRE : Supprimer le container avant reconstruction
docker compose down app

# 3Ô∏è‚É£ OBLIGATOIRE : Reconstruire l'image Docker sans cache
docker compose build --no-cache app

# 4Ô∏è‚É£ Red√©marrer le container avec la nouvelle image
docker compose up -d app

# 5Ô∏è‚É£ V√©rifier que l'application d√©marre correctement
docker compose logs app --tail=20
```

**‚ùå ERREURS COURANTES √Ä √âVITER** :
- Installer sur l'host puis reconstruire ‚Üí Probl√®mes de cache Docker
- Oublier de supprimer le container ‚Üí Ancienne image utilis√©e
- Reconstruire avec cache ‚Üí D√©pendances pas mises √† jour dans le container

**‚úÖ WORKFLOW D√âTAILL√â OBLIGATOIRE** :
1. `docker compose exec app npm install package` (DANS le container)
2. `docker compose down app` (OBLIGATOIRE - supprimer container)
3. `docker compose build --no-cache app` (OBLIGATOIRE - reconstruction sans cache)
4. `docker compose up -d app` (red√©marrage propre)
5. `docker compose logs app --tail=20` (v√©rification d√©marrage)

### **ÔøΩ R√àGLE CRITIQUE : MIGRATIONS EXCLUSIVEMENT DANS DOCKER**

**‚ö†Ô∏è WORKFLOW OBLIGATOIRE** : Toutes les migrations doivent √™tre ex√©cut√©es dans le container Docker pour √©viter les probl√®mes de compatibilit√© et d'environnement :

```bash
# ‚úÖ OBLIGATOIRE - Ex√©cuter migrations dans container
docker compose exec app npm run migration:run

# ‚úÖ OBLIGATOIRE - Rollback migrations dans container
docker compose exec app npm run migration:revert

# ‚úÖ OBLIGATOIRE - G√©n√©ration de migration dans container
docker compose exec app npm run migration:generate -- -n NameOfMigration

# ‚úÖ OBLIGATOIRE - Cr√©ation manuelle de migration dans container
docker compose exec app npm run migration:create -- -n NameOfMigration

# ‚úÖ OBLIGATOIRE - V√©rifier status migrations dans container
docker compose exec app npm run migration:show
```

### **üîß COMMANDES COURANTES DOCKER - R√âF√âRENCE RAPIDE**

```bash
# üß™ TESTS
docker compose exec app npm test                    # Tous les tests
docker compose exec app npm run test:unit          # Tests unitaires
docker compose exec app npm run test:integration   # Tests d'int√©gration
docker compose exec app npm run test:e2e          # Tests end-to-end
docker compose exec app npm run test:cov          # Coverage

# üîç QUALIT√â CODE
docker compose exec app npm run lint              # ESLint
docker compose exec app npm run lint -- --fix    # Auto-fix
docker compose exec app npm run format            # Prettier
docker compose exec app npx tsc --noEmit         # V√©rification TypeScript

# üèóÔ∏è BUILD
docker compose exec app npm run build             # Build production
docker compose exec app npm run start:dev         # Dev mode (dans container)

# üì¶ D√âPENDANCES
docker compose exec app npm install package-name  # Installer d√©pendance
docker compose exec app npm uninstall package-name # D√©sinstaller
docker compose exec app npm ci                    # Clean install
docker compose exec app npm audit                 # Audit s√©curit√©
docker compose exec app npm outdated              # D√©pendances obsol√®tes

# üóÑÔ∏è BASE DE DONN√âES
docker compose exec app npm run migration:run     # Ex√©cuter migrations
docker compose exec app npm run migration:revert  # Rollback migration
docker compose exec app npm run seed:run          # Ex√©cuter seeds
docker compose exec postgres-dev psql -U postgres -d appointment_system  # Acc√®s direct DB
```

### **üì¶ Services Docker Configur√©s**

- **üé® NestJS App** : Port 3000, hot reload, debugging
- **üêò PostgreSQL 15** : Port 5432, volume persistant, health checks
- **üçÉ MongoDB 7** : Port 27017, r√©plication configur√©e
- **üî¥ Redis** : Port 6379, cache utilisateur et sessions
- **üîß pgAdmin 4** : Port 5050, interface web DB management

### **üö® INTERDICTIONS ABSOLUES - COMMANDES HOST**

**‚ùå JAMAIS EX√âCUTER SUR L'HOST :**
- ‚ùå **JAMAIS** `npm run start:dev` directement sur la machine host
- ‚ùå **JAMAIS** `npm install` ou `npm ci` sur l'host
- ‚ùå **JAMAIS** `npm run test` sur l'host
- ‚ùå **JAMAIS** `npm run lint` sur l'host
- ‚ùå **JAMAIS** `npm run build` sur l'host
- ‚ùå **JAMAIS** `npx tsc` sur l'host
- ‚ùå **JAMAIS** `npm run migration:run` sur l'host
- ‚ùå **JAMAIS** installer PostgreSQL/Redis/MongoDB localement
- ‚ùå **JAMAIS** modifier les ports sans mettre √† jour docker-compose.yml
- ‚ùå **JAMAIS** utiliser node/npm directement sur l'host

**‚úÖ TOUJOURS OBLIGATOIRE - COMMANDES DOCKER :**
- ‚úÖ **TOUJOURS** `docker compose exec app npm run [command]`
- ‚úÖ **TOUJOURS** `docker compose exec app npm install [package]`
- ‚úÖ **TOUJOURS** `docker compose exec app npm run test`
- ‚úÖ **TOUJOURS** `docker compose exec app npm run lint`
- ‚úÖ **TOUJOURS** `docker compose exec app npm run build`
- ‚úÖ **TOUJOURS** `docker compose exec app npm run migration:run`
- ‚úÖ **TOUJOURS** utiliser Docker pour d√©veloppement, tests, d√©bogage, migrations

## ÔøΩÔ∏è **ARCHITECTURE DE BASE DE DONN√âES - CLEAN ARCHITECTURE OBLIGATOIRE**

### üéØ **R√àGLE CRITIQUE : ORGANISATION PAR TYPE DE BASE DE DONN√âES**

**‚ö†Ô∏è R√àGLE NON-N√âGOCIABLE** : Pour respecter la Clean Architecture et permettre de changer facilement de base de donn√©es (SQL/NoSQL), nous devons organiser les fichiers par type de driver sp√©cifique.

#### **üìÅ STRUCTURE OBLIGATOIRE DES COUCHES DONN√âES**

```
src/infrastructure/database/
‚îú‚îÄ‚îÄ database.module.ts                 # Module principal avec switch DB
‚îú‚îÄ‚îÄ typeorm.config.ts                  # Configuration g√©n√©rale TypeORM
‚îú‚îÄ‚îÄ typeorm-repositories.module.ts     # Module repositories TypeORM
‚îú‚îÄ‚îÄ sql/                              # ‚úÖ Bases de donn√©es SQL
‚îÇ   ‚îî‚îÄ‚îÄ postgresql/                   # ‚úÖ Driver PostgreSQL sp√©cifique
‚îÇ       ‚îú‚îÄ‚îÄ entities/                 # ‚úÖ Entit√©s ORM PostgreSQL
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ user-orm.entity.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ skill-orm.entity.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ service-category-orm.entity.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ service-type-orm.entity.ts
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ index.ts             # Export centralis√©
‚îÇ       ‚îú‚îÄ‚îÄ repositories/             # ‚úÖ Repositories PostgreSQL
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ typeorm-user.repository.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ typeorm-skill.repository.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ typeorm-service-category.repository.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ typeorm-service-type.repository.ts
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ index.ts             # Export centralis√©
‚îÇ       ‚îú‚îÄ‚îÄ migrations/               # ‚úÖ Migrations PostgreSQL
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ 1703701200000-CreateSkillsTable.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ 1703702000000-CreateServiceCategoriesTable.ts
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ 1703703000000-CreateServiceTypesTable.ts
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ       ‚îî‚îÄ‚îÄ utils/                    # ‚úÖ Utilitaires PostgreSQL
‚îú‚îÄ‚îÄ nosql/                           # ‚úÖ Bases de donn√©es NoSQL
‚îÇ   ‚îú‚îÄ‚îÄ mongodb/                     # ‚úÖ Driver MongoDB sp√©cifique
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ schemas/                 # Sch√©mas MongoDB
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/            # Repositories MongoDB
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ migrations/              # Migrations MongoDB
‚îÇ   ‚îî‚îÄ‚îÄ redis/                       # ‚úÖ Driver Redis sp√©cifique
‚îÇ       ‚îú‚îÄ‚îÄ schemas/
‚îÇ       ‚îî‚îÄ‚îÄ repositories/
‚îî‚îÄ‚îÄ orm/                             # ‚úÖ Mappers ORM g√©n√©riques
    ‚îî‚îÄ‚îÄ mappers/                     # ‚úÖ Conversion Domain ‚Üî Persistence
        ‚îú‚îÄ‚îÄ user-orm.mapper.ts
        ‚îú‚îÄ‚îÄ skill-orm.mapper.ts
        ‚îú‚îÄ‚îÄ service-category-orm.mapper.ts
        ‚îú‚îÄ‚îÄ service-type-orm.mapper.ts
        ‚îî‚îÄ‚îÄ index.ts
```

#### **üö® R√àGLES DE D√âPLACEMENT OBLIGATOIRES**

**‚ö†Ô∏è TOUS les fichiers doivent √™tre organis√©s selon cette hi√©rarchie :**

```bash
# ‚ùå INTERDIT - Fichiers dans mauvais r√©pertoire
src/infrastructure/database/entities/           # Trop g√©n√©rique
src/infrastructure/database/repositories/       # Trop g√©n√©rique

# ‚úÖ CORRECT - Fichiers dans structure sp√©cifique
src/infrastructure/database/sql/postgresql/entities/
src/infrastructure/database/sql/postgresql/repositories/
```

#### **üìã AVANTAGES DE CETTE ARCHITECTURE**

1. **üîÑ Swappable Database** : Changer facilement entre PostgreSQL, MySQL, MongoDB
2. **üéØ Isolation par Driver** : Chaque driver a sa propre impl√©mentation
3. **üì¶ Modulaire** : Ajouter/supprimer des drivers sans impact
4. **üß™ Tests Isol√©s** : Tests sp√©cifiques par type de base
5. **‚ö° Performance** : Optimisations sp√©cifiques par driver
6. **üîß Maintenance** : Code organis√© par responsabilit√© technique

#### **üõ†Ô∏è WORKFLOW DE MIGRATION OBLIGATOIRE**

**√âtape 1 : Identifier les fichiers mal plac√©s**
```bash
# Trouver tous les fichiers ORM/repositories mal plac√©s
find src/infrastructure/database -name "*-orm.entity.ts" -not -path "*/sql/postgresql/entities/*"
find src/infrastructure/database -name "typeorm-*.repository.ts" -not -path "*/sql/postgresql/repositories/*"
```

**√âtape 2 : D√©placer vers la structure correcte**
```bash
# D√©placer entit√©s ORM vers PostgreSQL
mv src/infrastructure/database/entities/*.ts src/infrastructure/database/sql/postgresql/entities/

# D√©placer repositories TypeORM vers PostgreSQL
mv src/infrastructure/database/repositories/typeorm-*.ts src/infrastructure/database/sql/postgresql/repositories/
```

**√âtape 3 : Mettre √† jour les imports**
```bash
# Corriger automatiquement les imports apr√®s d√©placement
npx ts-node scripts/fix-imports-after-db-migration.ts
```

#### **‚úÖ CHECKLIST ARCHITECTURE DATABASE OBLIGATOIRE**

- [ ] ‚úÖ **Entit√©s ORM** dans `sql/postgresql/entities/`
- [ ] ‚úÖ **Repositories TypeORM** dans `sql/postgresql/repositories/`
- [ ] ‚úÖ **Migrations** dans `sql/postgresql/migrations/`
- [ ] ‚úÖ **Mappers** dans `infrastructure/mappers/` (g√©n√©riques)
- [ ] ‚úÖ **Index exports** dans chaque sous-dossier
- [ ] ‚úÖ **Imports corrig√©s** apr√®s migration
- [ ] ‚úÖ **Tests** organis√©s selon m√™me structure
- [ ] ‚úÖ **Documentation** mise √† jour

#### **üö´ INTERDICTIONS ABSOLUES - ARCHITECTURE DB**

- ‚ùå **JAMAIS** de fichier ORM dans `database/entities/` (trop g√©n√©rique)
- ‚ùå **JAMAIS** de repository dans `database/repositories/` (trop g√©n√©rique)
- ‚ùå **JAMAIS** m√©langer drivers diff√©rents dans m√™me dossier
- ‚ùå **JAMAIS** d'import direct entre drivers (PostgreSQL ‚Üî MongoDB)
- ‚ùå **JAMAIS** de logique m√©tier dans couche infrastructure
- ‚ùå **JAMAIS** de couplage fort avec un driver sp√©cifique

### üîó **INT√âGRATION AVEC DOCKER ET MIGRATIONS**

```bash
# ‚úÖ OBLIGATOIRE - Migrations PostgreSQL dans Docker
docker compose exec app npm run migration:run

# ‚úÖ OBLIGATOIRE - Tests avec base PostgreSQL
docker compose exec app npm run test:integration

# ‚úÖ OBLIGATOIRE - Seed data PostgreSQL
docker compose exec app npm run seed:postgresql
```

**Cette organisation garantit une architecture flexible, maintenable et √©volutive !**

## ÔøΩüöÄ **NODE.JS 24 - NOUVELLES FONCTIONNALIT√âS √Ä EXPLOITER**

### üìã **Environnement Technique Requis**

- **Node.js Version** : `24.0.0` minimum (LTS recommand√©)
- **Documentation officielle** : https://nodejs.org/en/blog/release/v24.0.0
- **TypeScript** : `5.5+` pour compatibilit√© maximale avec Node 24

### ‚ö° **Nouvelles Fonctionnalit√©s Node.js 24 √† Utiliser**

#### **1. üîß Enhanced WebStreams Support**

```typescript
// ‚úÖ NOUVEAU - WebStreams natives optimis√©es
export class DataProcessor {
  async processLargeDataset(data: ReadableStream<Uint8Array>): Promise<void> {
    const transformer = new TransformStream({
      transform(chunk, controller) {
        // Processing logique m√©tier
        const processed = this.transformChunk(chunk);
        controller.enqueue(processed);
      }
    });

    await data
      .pipeThrough(transformer)
      .pipeTo(new WritableStream({
        write(chunk) {
          // Optimis√© par Node 24
          this.saveToDatabase(chunk);
        }
      }));
  }
}
```

#### **2. üöÄ Improved V8 Performance (v12.4)**

```typescript
// ‚úÖ NOUVEAU - Optimisations automatiques V8 pour:
export class PerformanceOptimizedService {
  // Object spread operations - 15% plus rapide
  private mergeConfigurations(base: Config, override: Partial<Config>): Config {
    return { ...base, ...override }; // Optimis√© par V8 12.4
  }

  // Array operations - 20% plus rapide
  private processLargeArrays<T>(items: T[]): T[] {
    return items
      .filter(this.isValid)
      .map(this.transform)
      .sort(this.compare); // Tri vectoris√© optimis√©
  }

  // String template literals - Am√©lior√©s
  private generateReport(data: ReportData): string {
    return `
      üìä Report Generated: ${new Date().toISOString()}
      üìà Total Items: ${data.items.length}
      üéØ Success Rate: ${(data.successRate * 100).toFixed(2)}%
    `; // Optimisation template string V8 12.4
  }
}
```

#### **3. üõ°Ô∏è Enhanced Security Features**

```typescript
// ‚úÖ NOUVEAU - Politique de s√©curit√© renforc√©e
export class SecureConfigService {
  constructor() {
    // Node 24 - Enhanced permission model
    if (process.permission?.has('fs.read', './config/')) {
      this.loadSecureConfig();
    }
  }

  // NOUVEAU - crypto.webcrypto optimis√©
  async generateSecureHash(data: string): Promise<string> {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);

    // WebCrypto API natif optimis√© Node 24
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    return Array.from(new Uint8Array(hashBuffer))
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
  }
}
```

#### **4. üì¶ Built-in Test Runner Am√©lior√©**

```typescript
// ‚úÖ NOUVEAU - Node.js native test runner enhanced
// package.json scripts
{
  "scripts": {
    "test:node": "node --test **/*.test.js",
    "test:node-watch": "node --test --watch **/*.test.js",
    "test:coverage": "node --test --experimental-test-coverage **/*.test.js"
  }
}

// Tests avec Node native runner
import { test, describe, it, before, after } from 'node:test';
import assert from 'node:assert';

describe('UserService Tests', () => {
  it('should create user successfully', async () => {
    const user = await userService.create({
      email: 'test@example.com',
      name: 'Test User'
    });

    // Node 24 - Am√©liorations assert
    assert.strictEqual(user.email, 'test@example.com');
    assert.ok(user.id);
  });
});
```

#### **5. üåç ESM & Import Attributes**

```typescript
// ‚úÖ NOUVEAU - Import attributes pour JSON
import config from './config.json' with { type: 'json' };
import packageInfo from '../package.json' with { type: 'json' };

// ‚úÖ NOUVEAU - Dynamic imports am√©lior√©s
export class DynamicModuleLoader {
  async loadPlugin(pluginName: string): Promise<any> {
    // Node 24 - R√©solution ESM optimis√©e
    const module = await import(`./plugins/${pluginName}.js`);
    return module.default;
  }

  // Top-level await dans ESM
  private config = await this.loadConfiguration();
}
```

#### **6. üîç Enhanced Debugging & Diagnostics**

```typescript
// ‚úÖ NOUVEAU - Diagnostics int√©gr√©s am√©lior√©s
export class DiagnosticsService {
  getSystemDiagnostics(): SystemDiagnostics {
    return {
      // Node 24 - M√©triques √©tendues
      memory: process.memoryUsage.rss(),
      heap: process.memoryUsage(),

      // NOUVEAU - Resource usage details
      resourceUsage: process.resourceUsage(),

      // NOUVEAU - Enhanced performance marks
      performanceMarks: performance.getEntriesByType('mark'),

      // Node 24 - Network diagnostics
      networkInterfaces: require('os').networkInterfaces()
    };
  }

  // NOUVEAU - Performance observer API am√©lior√©
  observePerformance(): void {
    const obs = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach((entry) => {
        this.logger.debug(`Performance: ${entry.name} took ${entry.duration}ms`);
      });
    });

    obs.observe({ entryTypes: ['function', 'http', 'dns'] });
  }
}
```

### üìã **Checklist Node.js 24 Migration**

- [ ] **Version Check** : `node --version` >= 24.0.0
- [ ] **ESM Migration** : Convertir vers `"type": "module"` si n√©cessaire
- [ ] **Import Attributes** : Utiliser `with { type: 'json' }` pour JSON
- [ ] **WebStreams** : Migrer vers WebStreams API natif
- [ ] **Test Runner** : √âvaluer l'utilisation du test runner natif
- [ ] **Performance** : Profiter des optimisations V8 12.4
- [ ] **Security** : Impl√©menter les nouvelles fonctionnalit√©s crypto
- [ ] **Diagnostics** : Int√©grer les nouveaux outils de monitoring

### üö® **Patterns Sp√©cifiques Node.js 24**

#### **Gestion M√©moire Optimis√©e**
```typescript
// ‚úÖ Node 24 - Weak references optimis√©es
export class CacheService {
  private cache = new WeakMap(); // Optimis√© pour GC
  private registry = new FinalizationRegistry((key) => {
    this.logger.debug(`Cache entry ${key} garbage collected`);
  });
}
```

#### **Worker Threads Am√©lior√©s**
```typescript
// ‚úÖ Node 24 - Worker threads performance
import { Worker, isMainThread, parentPort } from 'worker_threads';

export class ComputeService {
  async heavyComputation(data: any[]): Promise<any[]> {
    if (data.length > 1000) {
      // Node 24 - Optimized worker spawning
      return this.processInWorker(data);
    }
    return this.processInMain(data);
  }
}
```

### üéØ **Recommandations Architecture avec Node.js 24**

1. **ESM First** : Privil√©gier les modules ES natifs
2. **WebStreams** : Utiliser pour le traitement de gros volumes
3. **Native Test Runner** : Pour les tests unitaires simples
4. **Enhanced Crypto** : Pour la s√©curit√© renforc√©e
5. **Performance Monitoring** : Exploiter les nouveaux outils de diagnostic
6. **Worker Threads** : Pour les calculs intensifs

## üìä **√âTAT ACTUEL DU PROJET - BUSINESS FEATURES**

### ‚úÖ **FONCTIONNALIT√âS COMPL√àTEMENT IMPL√âMENT√âES**

#### **Staff Management (Personnel) - ‚úÖ 100% TERMIN√â AVEC SUCC√àS**
- ‚úÖ **Domain** : Staff Entity + Value Objects + Repository Interface
- ‚úÖ **Application** : CreateStaff, GetStaff, ListStaff, UpdateStaff, DeleteStaff Use Cases
- ‚úÖ **Infrastructure** : StaffOrmEntity + TypeOrmStaffRepository + StaffMapper + Migration
- ‚úÖ **Presentation** : StaffController + StaffDTO + Documentation Swagger **COMPLET**
- ‚úÖ **Documentation** : ‚úÖ docs/SWAGGER_STAFF_SERVICE_API.md cr√©√© avec exemples complets

#### **Service Management - ‚úÖ 100% TERMIN√â AVEC SUCC√àS**
- ‚úÖ **Domain** : Service Entity + Value Objects + Repository Interface
- ‚úÖ **Application** : CreateService, GetService, ListService, UpdateService, DeleteService Use Cases
- ‚úÖ **Infrastructure** : ServiceOrmEntity + TypeOrmServiceRepository + ServiceMapper + Migration
- ‚úÖ **Presentation** : ServiceController + ServiceDTO + Documentation Swagger **COMPLET**
- ‚úÖ **Documentation** : ‚úÖ docs/SWAGGER_STAFF_SERVICE_API.md cr√©√© avec exemples complets

#### **Appointment System - 100% COMPLET AVEC R√àGLES M√âTIER**
- ‚úÖ **Domain** : Appointment Entity + Value Objects + Repository Interface
- ‚úÖ **Application** : BookAppointment + GetAvailableSlots Use Cases avec r√®gles m√©tier
- ‚úÖ **Infrastructure** : AppointmentOrmEntity + TypeOrmAppointmentRepository + Mappers + Migration
- ‚úÖ **Business Rules** : **SEULS les services avec `allowOnlineBooking: true` peuvent √™tre r√©serv√©s**
- ‚úÖ **Exception Handling** : ServiceNotBookableOnlineError pour services non-publics
- ‚ö†Ô∏è **Presentation** : AppointmentController (PARTIEL - √Ä COMPL√âTER)
- ‚ùå **Documentation** : Documentation Swagger Appointment √† cr√©er apr√®s pr√©sentation

### ‚úÖ **FONCTIONNALIT√âS D√âJ√Ä TERMIN√âES (AVEC PRESENTATION)**
- **User Management** - Controllers + DTOs complets
- **Business Management** - Controllers + DTOs complets
- **Business Sector Management** - Controllers + DTOs complets
- **Calendar Management** - Controllers + DTOs complets
- **Health Checks** - Controller complet

### üéØ **PROCHAINE √âTAPE : PRESENTATION UNIQUEMENT**

**‚ö†Ô∏è IMPORTANT** : Pour Staff et Service, nous avons Domain + Application + Infrastructure COMPLETS.
Il ne manque QUE la couche Presentation (Controllers + DTOs).

**WORKFLOW SIMPLIFI√â POUR CES CAS** :
1. Cr√©er les DTOs typ√©s (validation + Swagger)
2. Cr√©er le Controller complet (CRUD + list)
3. Tests E2E
4. Documentation mise √† jour

## üèóÔ∏è **M√âTHODOLOGIE DE D√âVELOPPEMENT EN COUCHES ORDONN√âES - R√àGLE CRITIQUE NON-N√âGOCIABLE**

### üéØ **ORDRE OBLIGATOIRE DE D√âVELOPPEMENT - TDD STRICT**

**‚ö†Ô∏è R√àGLE FONDAMENTALE NON-N√âGOCIABLE** : Dans TOUTE cr√©ation, modification ou suppression de fonctionnalit√©, il faut OBLIGATOIREMENT partir de la couche Domain, puis Application, puis Infrastructure (y compris modifications et ex√©cution √©ventuelles des migrations), et ENFIN Presentation.

**üö® VIOLATION ARCHITECTURALE MAJEURE** : Commencer par les Controllers/DTOs (Presentation) sans avoir termin√© l'Infrastructure constitue une violation grave de la Clean Architecture et est **STRICTEMENT INTERDIT**.

**üéØ WORKFLOW OBLIGATOIRE - AUCUNE EXCEPTION AUTORIS√âE** :

1. **DOMAIN** (Entit√©s, Value Objects, Services m√©tier, Exceptions)
2. **APPLICATION** (Use Cases, Ports/Interfaces, Services applicatifs)
3. **INFRASTRUCTURE** (Repositories, ORM, Migrations TypeORM, Services techniques)
4. **PRESENTATION** (Controllers, DTOs, Mappers, Validation)

**Cette r√®gle s'applique pour :**
- ‚úÖ **Cr√©ation** de nouvelles fonctionnalit√©s
- ‚úÖ **Modification** de fonctionnalit√©s existantes
- ‚úÖ **Suppression** de fonctionnalit√©s
- ‚úÖ **Refactoring** architectural
- ‚úÖ **Ajout de propri√©t√©s** aux entit√©s
- ‚úÖ **Changement de logique m√©tier**

### üîÑ **PROCESSUS TDD PAR COUCHE - OBLIGATOIRE POUR TOUTE MODIFICATION** :

**üö® R√àGLE CRITIQUE** : Que ce soit pour cr√©er, modifier ou supprimer une fonctionnalit√©, TOUJOURS respecter cet ordre :

1. **üî¥ RED** : √âcrire le test qui √©choue pour la fonctionnalit√© dans la couche appropri√©e
2. **üü¢ GREEN** : √âcrire le code minimal qui fait passer le test
3. **üîµ REFACTOR** : Am√©liorer le code en gardant les tests verts
4. **‚úÖ VALIDATE** : V√©rifier que la couche compile et tous ses tests passent
5. **‚û°Ô∏è NEXT LAYER** : Passer √† la couche suivante UNIQUEMENT si la pr√©c√©dente est termin√©e

**‚ö†Ô∏è CAS D'USAGE CONCRETS OBLIGATOIRES** :

### üìù **CR√âATION D'UNE NOUVELLE FONCTIONNALIT√â**
```bash
1Ô∏è‚É£ DOMAIN       : Entit√© + Value Objects + Exceptions + Repository Interface + Tests
2Ô∏è‚É£ APPLICATION  : Use Cases + Validation + Ports + Tests
3Ô∏è‚É£ INFRASTRUCTURE: ORM Entity + Repository + Migration TypeORM + Tests
4Ô∏è‚É£ PRESENTATION : Controllers + DTOs + Validation + Swagger + Tests
```

### üîß **MODIFICATION D'UNE FONCTIONNALIT√â EXISTANTE**
```bash
1Ô∏è‚É£ DOMAIN       : Modification entit√© + validation m√©tier + tests mis √† jour
2Ô∏è‚É£ APPLICATION  : Modification use cases + nouvelles validations + tests
3Ô∏è‚É£ INFRASTRUCTURE: Migration TypeORM + modification ORM + repositories + tests
4Ô∏è‚É£ PRESENTATION : Modification DTOs + controllers + validation + tests
```

### üóëÔ∏è **SUPPRESSION D'UNE FONCTIONNALIT√â**
```bash
1Ô∏è‚É£ DOMAIN       : Marquage deprecated + validation suppression + tests
2Ô∏è‚É£ APPLICATION  : Use cases suppression + gestion d√©pendances + tests
3Ô∏è‚É£ INFRASTRUCTURE: Migration cleanup + suppression ORM + tests
4Ô∏è‚É£ PRESENTATION : Suppression endpoints + DTOs + documentation
```

### ‚ö†Ô∏è **R√àGLES CRITIQUES NON-N√âGOCIABLES**
- ‚ùå **JAMAIS** d√©velopper plusieurs fonctionnalit√©s simultan√©ment
- ‚ùå **JAMAIS** passer √† la couche suivante si la pr√©c√©dente a des tests qui √©chouent
- ‚ùå **JAMAIS** √©crire du code sans test pr√©alable (TDD strict)
- ‚ùå **JAMAIS** ignorer les erreurs de compilation d'une couche
- ‚ùå **JAMAIS** commencer par la Presentation sans Infrastructure compl√®te
- ‚ùå **JAMAIS** modifier une entit√© sans migration TypeORM appropri√©e
- ‚ùå **JAMAIS** cr√©er/modifier/supprimer sans suivre l'ordre Domain ‚Üí Application ‚Üí Infrastructure ‚Üí Presentation
- ‚úÖ **TOUJOURS** une seule fonctionnalit√© √† la fois (ex: CreateUser ‚Üí UpdateUser ‚Üí DeleteUser)
- ‚úÖ **TOUJOURS** finir compl√®tement une couche avant de passer √† la suivante
- ‚úÖ **TOUJOURS** √©crire les tests AVANT le code (TDD strict)
- ‚úÖ **TOUJOURS** valider la compilation apr√®s chaque modification
- ‚úÖ **TOUJOURS** ex√©cuter et tester les migrations avant la couche Presentation

### üìã **WORKFLOW D√âTAILL√â PAR COUCHE**

#### **üèóÔ∏è Exemple Concret : Fonctionnalit√© "Create Business"**

**√âtape 1Ô∏è‚É£ : DOMAIN** (Obligatoire en premier)
```bash
# 1. Cr√©er les tests d'entit√© Business
touch src/domain/entities/business.entity.spec.ts
# 2. √âcrire les tests qui √©chouent (RED)
# 3. Cr√©er l'entit√© Business (GREEN)
# 4. Refactorer si n√©cessaire (REFACTOR)
# 5. Valider : npm test -- business.entity.spec.ts
```

**√âtape 2Ô∏è‚É£ : APPLICATION** (Seulement apr√®s Domain termin√©)
```bash
# 1. Cr√©er les tests de use case
touch src/application/use-cases/business/create-business.use-case.spec.ts
# 2. √âcrire les tests qui √©chouent (RED)
# 3. Cr√©er le use case CreateBusinessUseCase (GREEN)
# 4. Cr√©er l'interface BusinessRepository dans domain/repositories/
# 5. Refactorer si n√©cessaire (REFACTOR)
# 6. Valider : npm test -- create-business.use-case.spec.ts
```

**√âtape 3Ô∏è‚É£ : INFRASTRUCTURE** (Seulement apr√®s Application termin√© - ‚ö†Ô∏è OBLIGATOIRE AVANT PRESENTATION)
```bash
# 1. Cr√©er les tests de repository
touch src/infrastructure/database/repositories/typeorm-business.repository.spec.ts
# 2. √âcrire les tests qui √©chouent (RED)
# 3. ‚ö†Ô∏è CRITIQUE : Cr√©er Migration TypeORM OBLIGATOIRE EN PREMIER
touch src/infrastructure/database/sql/postgresql/migrations/{timestamp}-Create{Entity}Table.ts
# 4. üö® √âTAPE OBLIGATOIRE : TESTER LA MIGRATION AVANT TOUT CODE
docker-compose exec nestjs-dev npm run migration:run
docker-compose exec nestjs-dev npm run migration:revert  # V√©rifier le rollback
docker-compose exec nestjs-dev npm run migration:run     # Re-appliquer
# 5. ‚ö†Ô∏è CRITIQUE : VALIDER QUE LA MIGRATION FONCTIONNE SANS ERREUR
# Si erreurs ‚Üí STOP et corriger la migration avant de continuer
# 6. Cr√©er l'entit√© ORM BusinessOrmEntity (GREEN)
# 7. Cr√©er/Mettre √† jour les Mappers statiques dans /infrastructure/mappers/ (GREEN)
# 8. Cr√©er TypeOrmBusinessRepository qui impl√©mente BusinessRepository (GREEN)
# 9. Configurer l'injection de d√©pendances dans TypeOrmRepositoriesModule (GREEN)
# 10. Refactorer si n√©cessaire (REFACTOR)
# 11. Valider : npm test -- typeorm-business.repository.spec.ts
```

### üö® **R√àGLE CRITIQUE : MIGRATION VALID√âE AVANT PR√âSENTATION**

**‚ö†Ô∏è R√àGLE NON-N√âGOCIABLE** : **JAMAIS** passer √† la couche Presentation sans avoir valid√© que les migrations fonctionnent parfaitement.

**WORKFLOW OBLIGATOIRE MIGRATIONS :**

```bash
# 1Ô∏è‚É£ CR√âER la migration
touch src/infrastructure/database/sql/postgresql/migrations/{timestamp}-Create{Entity}Table.ts

# 2Ô∏è‚É£ TESTER dans Docker (OBLIGATOIRE)
docker-compose exec nestjs-dev npm run migration:run

# 3Ô∏è‚É£ V√âRIFIER le rollback
docker-compose exec nestjs-dev npm run migration:revert

# 4Ô∏è‚É£ RE-APPLIQUER pour validation finale
docker-compose exec nestjs-dev npm run migration:run

# 5Ô∏è‚É£ V√âRIFIER les tables cr√©√©es
docker-compose exec postgres-dev psql -U postgres -d appointment_system -c "\dt"

# 6Ô∏è‚É£ SEULEMENT SI SUCC√àS ‚Üí Continuer vers ORM Entity et Repository
```

**üö® SI ERREURS DE MIGRATION :**
- **STOP** imm√©diatement le d√©veloppement
- **CORRIGER** la migration avant toute autre action
- **RE-TESTER** jusqu'√† succ√®s complet
- **JAMAIS** ignorer les erreurs de migration

**√âtape 4Ô∏è‚É£ : PRESENTATION** (Seulement apr√®s Infrastructure termin√©)
```bash
# 1. Cr√©er les tests de controller
touch src/presentation/controllers/business.controller.spec.ts
# 2. √âcrire les tests qui √©chouent (RED)
# 3. Cr√©er les DTOs de validation (GREEN)
# 4. Cr√©er BusinessController (GREEN)
# 5. Configurer la validation et la documentation Swagger (GREEN)
# 6. Refactorer si n√©cessaire (REFACTOR)
# 7. Valider : npm test -- business.controller.spec.ts
# 8. Test d'int√©gration E2E : npm run test:e2e -- business
```

### üö® **VIOLATIONS COURANTES √Ä √âVITER**
- **Commencer par le controller** ‚Üí ‚ùå Violation de Clean Architecture
- **Cr√©er l'entit√© ORM avant l'entit√© Domain** ‚Üí ‚ùå Violation de d√©pendance
- **√âcrire du code sans test** ‚Üí ‚ùå Violation de TDD
- **Passer √† Infrastructure avec des tests Application qui √©chouent** ‚Üí ‚ùå Violation de workflow
- **‚ö†Ô∏è CRITIQUE : Cr√©er Controller/DTOs sans Migration TypeORM test√©e** ‚Üí ‚ùå Violation Infrastructure manquante
- **üö® NOUVEAU : Passer √† Presentation sans tester migration:run/revert** ‚Üí ‚ùå Violation s√©curit√© DB

#### **1Ô∏è‚É£ DOMAIN (Couche M√©tier) - EN PREMIER**
```
src/domain/
‚îú‚îÄ‚îÄ entities/          # Entit√©s m√©tier pures
‚îú‚îÄ‚îÄ value-objects/     # Objets valeur immutables
‚îú‚îÄ‚îÄ services/          # Services m√©tier (r√®gles complexes)
‚îú‚îÄ‚îÄ repositories/      # Interfaces repositories (ports)
‚îî‚îÄ‚îÄ exceptions/        # Exceptions m√©tier sp√©cifiques
```
**‚úÖ Caract√©ristiques** :
- **Z√âRO d√©pendance externe** (pas de NestJS, pas d'ORM, pas de framework)
- **Pure TypeScript** avec types stricts
- **Logique m√©tier uniquement**
- **Testable en isolation**

#### **2Ô∏è‚É£ APPLICATION (Cas d'Usage) - EN SECOND**
```
src/application/
‚îú‚îÄ‚îÄ services/          # Services applicatifs (PR√âF√âRER aux use-cases)
‚îú‚îÄ‚îÄ ports/             # Interfaces pour l'infrastructure
‚îú‚îÄ‚îÄ use-cases/         # Cases d'utilisation (seulement si n√©cessaire)
‚îî‚îÄ‚îÄ exceptions/        # Exceptions applicatives
```
**‚úÖ Caract√©ristiques** :
- **PR√âF√âRER les Services** aux Use Cases complexes
- **D√©pend UNIQUEMENT** de la couche Domain
- **Z√âRO d√©pendance** vers Infrastructure ou Presentation
- **Orchestration simple** des entit√©s et services m√©tier
- **D√©finit les ports** (interfaces) pour l'infrastructure
- **Logique d'application claire** et testable

#### **3Ô∏è‚É£ INFRASTRUCTURE (Technique) - EN TROISI√àME**
```
src/infrastructure/
‚îú‚îÄ‚îÄ database/          # Repositories concrets, ORM, migrations
‚îú‚îÄ‚îÄ services/          # Services techniques (JWT, Email, etc.)
‚îú‚îÄ‚îÄ config/            # Configuration
‚îî‚îÄ‚îÄ security/          # S√©curit√© technique
```
**‚úÖ Caract√©ristiques** :
- **Impl√©mente les ports** d√©finis dans Application
- **Peut utiliser NestJS** et autres frameworks
- **Aucune logique m√©tier**
- **Adaptateurs** vers le monde externe

#### **4Ô∏è‚É£ PRESENTATION (Interface) - EN DERNIER**
```
src/presentation/
‚îú‚îÄ‚îÄ controllers/       # Contr√¥leurs HTTP
‚îú‚îÄ‚îÄ dtos/              # Objets de transfert
‚îú‚îÄ‚îÄ decorators/        # D√©corateurs NestJS
‚îî‚îÄ‚îÄ mappers/           # Conversion DTO ‚Üî Domain
```
**‚úÖ Caract√©ristiques** :
- **Orchestration** des Services Application (PAS d'Use Cases complexes)
- **Validation** des entr√©es avec class-validator
- **S√©rialisation** des sorties
- **Documentation Swagger** compl√®te et d√©taill√©e
- **Support i18n** pour messages d'erreur
- **Interface utilisateur** (REST, GraphQL, etc.)

### üìß **R√àGLE PORTS & ADAPTERS pour Services Externes**
**Tous les services externes (Email, SMS, etc.) DOIVENT √™tre des ports/adapters :**
- **Port** (Interface) dans `/application/ports/`
- **Adapter** (Impl√©mentation) dans `/infrastructure/services/`
- **Exemples** : EmailPort ‚Üí GmailAdapter, SmsPort ‚Üí TwilioAdapter

### üóÑÔ∏è **R√àGLE OBLIGATOIRE : MIGRATIONS TYPEORM POUR NOUVELLES ENTIT√âS**
**Pour chaque nouvelle entit√© cr√©√©e dans la couche infrastructure, cr√©er SYST√âMATIQUEMENT :**
- **Migration TypeORM** dans `/src/infrastructure/database/sql/postgresql/migrations/`
- **Nom du fichier** : `{timestamp}-{ActionEntityTable}.ts` (ex: `1695829200000-CreateAppointmentsTable.ts`)
- **Contenu** : Utiliser l'API TypeORM 0.3+ avec `QueryRunner`
- **Validation** : Tester la migration avant de commiter

#### **üõ†Ô∏è Template Obligatoire pour Migration TypeORM**

```typescript
import { MigrationInterface, QueryRunner, Table, Index, ForeignKey } from 'typeorm';

export class Create{Entity}Table{Timestamp} implements MigrationInterface {
  name = 'Create{Entity}Table{Timestamp}';

  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(
      new Table({
        name: '{entity_name}s',
        columns: [
          {
            name: 'id',
            type: 'uuid',
            isPrimary: true,
            generationStrategy: 'uuid',
            default: 'uuid_generate_v4()',
          },
          // Autres colonnes...
          {
            name: 'created_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
          },
          {
            name: 'updated_at',
            type: 'timestamp',
            default: 'CURRENT_TIMESTAMP',
            onUpdate: 'CURRENT_TIMESTAMP',
          },
        ],
      }),
      true,
    );

    // Index et Foreign Keys si n√©cessaire
    await queryRunner.createIndex('{entity_name}s', new Index('{entity_name}_idx', ['column']));

    // Foreign Keys
    await queryRunner.createForeignKey('{entity_name}s', new ForeignKey({
      columnNames: ['foreign_column_id'],
      referencedTableName: 'referenced_table',
      referencedColumnNames: ['id'],
      onDelete: 'CASCADE',
    }));
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable('{entity_name}s');
  }
}
```

#### **üìã Checklist Migration Obligatoire**
- [ ] ‚úÖ **Nom du fichier** respecte le format `{timestamp}-{Action}{Entity}Table.ts`
- [ ] ‚úÖ **UUID par d√©faut** avec `uuid_generate_v4()`
- [ ] ‚úÖ **created_at/updated_at** avec defaults appropri√©s
- [ ] ‚úÖ **Index** sur les colonnes fr√©quemment utilis√©es
- [ ] ‚úÖ **Foreign Keys** avec contraintes appropri√©es (`CASCADE`, `RESTRICT`)
- [ ] ‚úÖ **M√©thode down()** pour rollback complet
- [ ] ‚úÖ **Test migration** avec `npm run migration:run` et `npm run migration:revert`

### üöÄ **AVANTAGES DE CETTE APPROCHE**

#### **‚úÖ R√©duction des Erreurs**
- **Pas de d√©pendances circulaires** : chaque couche ne d√©pend que des pr√©c√©dentes
- **Compilation incr√©mentale** : chaque couche compile avant de passer √† la suivante
- **D√©tection pr√©coce** des violations architecturales

#### **‚úÖ D√©veloppement Efficace**
- **Focus progressif** : une pr√©occupation √† la fois
- **Tests cibl√©s** : chaque couche testable ind√©pendamment
- **Refactoring s√ªr** : modifications isol√©es par couche

#### **‚úÖ Qualit√© Architecturale**
- **Respect automatique** des principes Clean Architecture
- **S√©paration claire** des responsabilit√©s
- **√âvolutivit√©** et maintenabilit√© garanties

### ‚úÖ **CHECKPOINTS DE VALIDATION OBLIGATOIRES**

**√Ä chaque fin de couche, v√©rifier OBLIGATOIREMENT :**

#### **üîç Checkpoint Domain**
```bash
# Tests unitaires Domain
npm test -- --testPathPattern=domain/ --coverage
# Compilation TypeScript
npm run build
# Linting sans erreur
npm run lint
# R√âSULTAT ATTENDU : 100% tests passants, 0 erreur compilation, 0 erreur lint
```

#### **üîç Checkpoint Application**
```bash
# Tests unitaires Application + Domain
npm test -- --testPathPattern="(domain|application)/" --coverage
# V√©rification des interfaces (ports)
# R√âSULTAT ATTENDU : Coverage > 80%, toutes les interfaces d√©finies, 0 erreur
```

#### **ÔøΩ Checkpoint Infrastructure**
```bash
# Tests unitaires Infrastructure + couches pr√©c√©dentes
npm test -- --testPathPattern="(domain|application|infrastructure)/" --coverage
# Tests d'int√©gration base de donn√©es
npm run test:integration
# R√âSULTAT ATTENDU : Connexion DB OK, repositories fonctionnels, DI configur√©
```

#### **üîç Checkpoint Presentation**
```bash
# Tests complets + E2E
npm test
npm run test:e2e
# Test de d√©marrage application
npm run start:dev
# R√âSULTAT ATTENDU : Application d√©marre, endpoints r√©pondent, documentation Swagger
```

### ÔøΩüìã **WORKFLOW PRATIQUE - EXEMPLE CONCRET**

```typescript
// 1Ô∏è‚É£ DOMAIN - Cr√©er d'abord l'entit√© (avec test RED-GREEN-REFACTOR)
export class User {
  private constructor(
    private readonly _id: string,
    private readonly _email: Email,
    private readonly _name: string,
  ) {}

  static create(email: Email, name: string): User {
    // Validation m√©tier
    return new User(generateId(), email, name);
  }
}

// 2Ô∏è‚É£ APPLICATION - Puis le use case
export class CreateUserUseCase {
  constructor(
    private readonly userRepository: IUserRepository, // Interface d√©finie ici
  ) {}

  async execute(request: CreateUserRequest): Promise<CreateUserResponse> {
    // Orchestration m√©tier
  }
}

// 3Ô∏è‚É£ INFRASTRUCTURE - Ensuite l'impl√©mentation
export class TypeOrmUserRepository implements IUserRepository {
  // Impl√©mentation technique
}

// 4Ô∏è‚É£ PRESENTATION - Enfin le contr√¥leur
@Controller('users')
export class UserController {
  constructor(private readonly createUserUseCase: CreateUserUseCase) {}

  @Post()
  async create(@Body() dto: CreateUserDto) {
    // Interface utilisateur
  }
}
```

### ‚ö†Ô∏è **INTERDICTIONS ABSOLUES - WORKFLOW TDD**

#### **‚ùå Ne JAMAIS faire** :
- **Commencer par les contr√¥leurs** (Presentation) ‚Üí ‚ùå Violation Clean Architecture
- **D√©velopper plusieurs couches simultan√©ment** ‚Üí ‚ùå Violation TDD
- **√âcrire du code sans test** ‚Üí ‚ùå Violation TDD strict
- **Passer √† la couche suivante avec des tests qui √©chouent** ‚Üí ‚ùå Violation workflow
- **√âcrire de la logique m√©tier dans Infrastructure** ‚Üí ‚ùå Violation s√©paration
- **Utiliser NestJS dans Domain/Application** ‚Üí ‚ùå Violation ind√©pendance framework
- **Cr√©er des d√©pendances vers les couches sup√©rieures** ‚Üí ‚ùå Violation Dependency Rule
- **Ignorer les erreurs de compilation/lint** ‚Üí ‚ùå Violation qualit√© code

#### **‚úÖ TOUJOURS faire - WORKFLOW OBLIGATOIRE** :
- **Respecter l'ordre strict** : Domain ‚Üí Application ‚Üí Infrastructure ‚Üí Presentation
- **TDD √† chaque √©tape** : RED ‚Üí GREEN ‚Üí REFACTOR ‚Üí VALIDATE
- **Tester chaque couche compl√®tement** avant de passer √† la suivante
- **Valider compilation + lint** √† chaque modification
- **Documenter les interfaces (ports)** dans Application
- **Une fonctionnalit√© √† la fois** jusqu'√† completion E2E
- **Checkpoints de validation** obligatoires entre couches

#### **üö® D√âTECTION PR√âCOCE DES VIOLATIONS**

```bash
# V√©rifier les imports interdits dans Domain/Application
grep -r "@nestjs\|typeorm\|express" src/domain/ src/application/
# R√âSULTAT ATTENDU : Aucun r√©sultat (0 ligne)

# V√©rifier les d√©pendances circulaires
npx madge --circular src/
# R√âSULTAT ATTENDU : No circular dependencies found

# V√©rifier la structure des tests par couche
find src/ -name "*.spec.ts" | head -20
# R√âSULTAT ATTENDU : Tests pr√©sents dans chaque couche
```

#### **üîÑ CORRECTION DES VIOLATIONS**

Si une violation est d√©tect√©e :
1. **STOP** le d√©veloppement imm√©diatement
2. **ROLLBACK** aux derniers tests passants
3. **ANALYSER** la cause de la violation
4. **REPRENDRE** depuis la derni√®re couche valid√©e
5. **APPLIQUER** le workflow TDD strict

### üß™ **TEST-DRIVEN DEVELOPMENT (TDD) - PRATIQUES OBLIGATOIRES**

#### **üéØ Cycle TDD Red-Green-Refactor**

**Pour CHAQUE fonctionnalit√©, suivre ce cycle dans CHAQUE couche :**

1. **üî¥ RED Phase** :
   ```bash
   # √âcrire le test qui √©choue AVANT le code
   npm test -- some.spec.ts
   # R√âSULTAT ATTENDU : Test fails (RED)
   ```

2. **üü¢ GREEN Phase** :
   ```bash
   # √âcrire le code minimal qui fait passer le test
   npm test -- some.spec.ts
   # R√âSULTAT ATTENDU : Test passes (GREEN)
   ```

3. **üîµ REFACTOR Phase** :
   ```bash
   # Am√©liorer le code en gardant les tests verts
   npm test -- some.spec.ts
   npm run lint
   # R√âSULTAT ATTENDU : Tests pass + code quality
   ```

#### **üìã Structure de Tests par Couche**

**Domain Layer Tests** :
```typescript
// ‚úÖ Tests d'entit√©s avec r√®gles m√©tier
describe('User Entity', () => {
  it('should create user with valid data', () => {
    // Test de cr√©ation valide
  });

  it('should throw error with invalid email', () => {
    // Test de validation m√©tier
  });
});

// ‚úÖ Tests de Value Objects
describe('Email Value Object', () => {
  it('should validate email format', () => {
    // Test de validation format
  });
});
```

**Application Layer Tests** :
```typescript
// ‚úÖ Tests de Use Cases avec mocks
describe('CreateUserUseCase', () => {
  let useCase: CreateUserUseCase;
  let mockUserRepo: jest.Mocked<IUserRepository>;

  beforeEach(() => {
    mockUserRepo = createMockUserRepository();
    useCase = new CreateUserUseCase(mockUserRepo);
  });

  it('should create user successfully', async () => {
    // Test du cas nominal
  });
});
```

**Infrastructure Layer Tests** :
```typescript
// ‚úÖ Tests d'int√©gration avec base de donn√©es
describe('TypeOrmUserRepository', () => {
  let repository: TypeOrmUserRepository;
  let connection: Connection;

  beforeAll(async () => {
    connection = await createTestConnection();
    repository = new TypeOrmUserRepository(connection);
  });

  it('should save user to database', async () => {
    // Test de persistence r√©elle
  });
});
```

**Presentation Layer Tests** :
```typescript
// ‚úÖ Tests E2E complets
describe('UserController (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    app = await createTestApp();
  });

  it('/users (POST)', () => {
    return request(app.getHttpServer())
      .post('/users')
      .send(validUserDto)
      .expect(201);
  });
});
```

#### **üéØ Couverture de Tests Minimale**

- **Domain** : 95%+ coverage obligatoire
- **Application** : 90%+ coverage obligatoire
- **Infrastructure** : 80%+ coverage acceptable
- **Presentation** : 85%+ coverage avec E2E

#### **‚ö†Ô∏è R√àGLES TDD NON-N√âGOCIABLES**

- ‚ùå **Z√âRO code sans test pr√©alable**
- ‚ùå **Z√âRO test ignor√© (.skip ou .todo)**
- ‚ùå **Z√âRO commit avec tests qui √©chouent**
- ‚úÖ **Tests AVANT le code (RED-GREEN-REFACTOR)**
- ‚úÖ **Un test = une responsabilit√©**
- ‚úÖ **Tests lisibles et maintenables**
- ‚úÖ **Mocks pour les d√©pendances externes**

## üèõÔ∏è **Clean Architecture - Principes Fondamentaux d'Uncle Bob**

### üìö **R√©f√©rence Officielle**

**Source** : [The Clean Architecture par Robert C. Martin](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

### üéØ **Objectifs de la Clean Architecture**

La Clean Architecture produit des syst√®mes qui sont :

1. **üîß Independent of Frameworks** - L'architecture ne d√©pend pas de l'existence de frameworks. Vous utilisez les frameworks comme des outils, plut√¥t que de contraindre votre syst√®me dans leurs limitations.

2. **üß™ Testable** - Les r√®gles m√©tier peuvent √™tre test√©es sans UI, Database, Web Server, ou tout autre √©l√©ment externe.

3. **üé® Independent of UI** - L'UI peut changer facilement, sans changer le reste du syst√®me. Une Web UI peut √™tre remplac√©e par une console UI sans changer les r√®gles m√©tier.

4. **üóÑÔ∏è Independent of Database** - Vous pouvez √©changer Oracle ou SQL Server pour Mongo, BigTable, CouchDB, ou autre chose. Vos r√®gles m√©tier ne sont pas li√©es √† la base de donn√©es.

5. **üåê Independent of any external agency** - Vos r√®gles m√©tier ne savent simplement rien du monde ext√©rieur.

### üîÑ **The Dependency Rule - R√àGLE FONDAMENTALE**

> **"Source code dependencies can only point inwards"**

![Clean Architecture Circles](https://blog.cleancoder.com/uncle-bob/images/2012-08-13-the-clean-architecture/CleanArchitecture.jpg)

**Les cercles concentriques repr√©sentent diff√©rentes zones du logiciel :**

- Plus vous allez vers l'int√©rieur, plus le niveau du logiciel est √©lev√©
- Les cercles ext√©rieurs sont des m√©canismes
- Les cercles int√©rieurs sont des politiques

**‚ùå INTERDIT** : Rien dans un cercle int√©rieur ne peut conna√Ætre quoi que ce soit d'un cercle ext√©rieur
**‚ùå INTERDIT** : Le nom de quelque chose d√©clar√© dans un cercle ext√©rieur ne doit pas √™tre mentionn√© par le code dans un cercle int√©rieur

## üö® **R√àGLE CRITIQUE - AUCUNE D√âPENDANCE NESTJS DANS DOMAIN/APPLICATION**

### ‚ùå **VIOLATIONS ABSOLUMENT INTERDITES**

Les couches **Domain** et **Application** NE DOIVENT JAMAIS contenir :
- `import { Injectable, Inject } from '@nestjs/common'`
- `@Injectable()` decorator
- `@Inject()` decorator
- Aucun import de `@nestjs/*` packages
- Aucune r√©f√©rence aux tokens d'injection NestJS

### ‚úÖ **APPROCHE CORRECTE**

```typescript
// ‚ùå INTERDIT - Violation de Clean Architecture
import { Injectable, Inject } from '@nestjs/common';

@Injectable()
export class CreateUserUseCase {
  constructor(
    @Inject('USER_REPOSITORY') private userRepo: IUserRepository
  ) {}
}

// ‚úÖ CORRECT - Clean Architecture respect√©e
export class CreateUserUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly logger: Logger,
    private readonly i18n: I18nService,
  ) {}
}
```

### üèóÔ∏è **S√©paration des Responsabilit√©s**

- **Domain/Application** : Logic m√©tier pure, sans framework
- **Infrastructure** : Impl√©mentations techniques avec NestJS
- **Presentation** : Controllers NestJS qui orchestrent les Use Cases

### üîó **Injection de D√©pendances**

L'injection NestJS se fait UNIQUEMENT dans la couche **Presentation/Infrastructure** :
```typescript
// Dans presentation/controllers/*.controller.ts
@Controller()
export class UserController {
  constructor(
    @Inject(TOKENS.CREATE_USER_USE_CASE)
    private readonly createUserUseCase: CreateUserUseCase
  ) {}
}
```

**Cette r√®gle est NON-N√âGOCIABLE pour maintenir les principes de Clean Architecture !**

## üó∫Ô∏è **MAPPERS - PATTERN OBLIGATOIRE POUR CONVERSION DE DONN√âES**

### üéØ **R√àGLE CRITIQUE : Z√âRO LOGIQUE DE MAPPING DANS LES ENTIT√âS ORM**

**‚ùå VIOLATION ARCHITECTURALE MAJEURE :**
Les entit√©s ORM (TypeORM, Prisma, etc.) NE DOIVENT JAMAIS contenir de logique de conversion vers les entit√©s Domain. Cette responsabilit√© appartient exclusivement aux Mappers d√©di√©s dans `/infrastructure/mappers/`.

### üö´ **INTERDICTIONS ABSOLUES**

```typescript
// ‚ùå STRICTEMENT INTERDIT - Logique m√©tier dans l'entit√© ORM
@Entity('users')
export class UserOrmEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  // ‚ùå JAMAIS de m√©thode toDomainEntity() dans l'entit√© ORM
  toDomainEntity(): User {
    const email = Email.create(this.email);
    return User.create(email, this.name); // VIOLATION !
  }

  // ‚ùå JAMAIS d'imports domaine dans les entit√©s ORM
  // import { User } from '../../../domain/entities/user.entity';
}
```

### ‚úÖ **PATTERN CORRECT : MAPPERS D√âDI√âS**

```typescript
// ‚úÖ EXCELLENT - Mapper d√©di√© dans /infrastructure/mappers/
export class UserOrmMapper {
  /**
   * Convertit une entit√© Domain vers ORM pour persistence
   */
  static toOrmEntity(domain: User): UserOrmEntity {
    const ormEntity = new UserOrmEntity();
    ormEntity.id = domain.getId().getValue();
    ormEntity.email = domain.getEmail().getValue();
    ormEntity.name = domain.getName();
    ormEntity.role = domain.getRole();
    ormEntity.created_at = domain.getCreatedAt();
    ormEntity.updated_at = domain.getUpdatedAt();
    return ormEntity;
  }

  /**
   * Convertit une entit√© ORM vers Domain depuis persistence
   */
  static toDomainEntity(orm: UserOrmEntity): User {
    const email = Email.create(orm.email);
    const userId = UserId.fromString(orm.id);

    return User.reconstruct({
      id: userId,
      email: email,
      name: orm.name,
      role: orm.role,
      createdAt: orm.created_at,
      updatedAt: orm.updated_at,
    });
  }

  /**
   * Convertit liste ORM vers Domain
   */
  static toDomainEntities(ormEntities: UserOrmEntity[]): User[] {
    return ormEntities.map(orm => this.toDomainEntity(orm));
  }
}
```

### üìÅ **STRUCTURE OBLIGATOIRE DES MAPPERS**

```
src/infrastructure/mappers/
‚îú‚îÄ‚îÄ orm-mappers.ts           # Export centralis√© de tous les mappers
‚îú‚îÄ‚îÄ user-orm.mapper.ts       # Mapper User : Domain ‚Üî ORM
‚îú‚îÄ‚îÄ business-orm.mapper.ts   # Mapper Business : Domain ‚Üî ORM
‚îú‚îÄ‚îÄ service-orm.mapper.ts    # Mapper Service : Domain ‚Üî ORM
‚îî‚îÄ‚îÄ staff-orm.mapper.ts      # Mapper Staff : Domain ‚Üî ORM
```

### üîÑ **RESPONSABILIT√âS DES MAPPERS**

#### **1Ô∏è‚É£ Conversion Domain ‚Üí ORM (Persistence)**
```typescript
// Pour les op√©rations CREATE et UPDATE
static toOrmEntity(domain: DomainEntity): OrmEntity {
  // Conversion des Value Objects vers types primitifs
  // Gestion des relations et foreign keys
  // Pr√©paration pour persistence en base
}
```

#### **2Ô∏è‚É£ Conversion ORM ‚Üí Domain (Reconstruction)**
```typescript
// Pour les op√©rations READ et hydratation
static toDomainEntity(orm: OrmEntity): DomainEntity {
  // Reconstruction des Value Objects depuis primitifs
  // Validation et cr√©ation des entit√©s Domain
  // Pr√©servation de l'int√©grit√© m√©tier
}
```

#### **3Ô∏è‚É£ Conversion Batch (Collections)**
```typescript
// Pour les op√©rations sur collections
static toDomainEntities(ormList: OrmEntity[]): DomainEntity[] {
  return ormList.map(orm => this.toDomainEntity(orm));
}

static toOrmEntities(domainList: DomainEntity[]): OrmEntity[] {
  return domainList.map(domain => this.toOrmEntity(domain));
}
```

### üèóÔ∏è **UTILISATION DANS LES REPOSITORIES**

```typescript
// ‚úÖ EXCELLENT - Usage correct des mappers dans Repository
@Injectable()
export class TypeOrmUserRepository implements IUserRepository {
  constructor(
    @InjectRepository(UserOrmEntity)
    private readonly repository: Repository<UserOrmEntity>,
  ) {}

  async save(user: User): Promise<User> {
    // 1. Conversion Domain ‚Üí ORM via Mapper
    const ormEntity = UserOrmMapper.toOrmEntity(user);

    // 2. Persistence en base
    const savedOrm = await this.repository.save(ormEntity);

    // 3. Conversion ORM ‚Üí Domain via Mapper
    return UserOrmMapper.toDomainEntity(savedOrm);
  }

  async findById(id: UserId): Promise<User | null> {
    // 1. Requ√™te ORM
    const ormEntity = await this.repository.findOne({
      where: { id: id.getValue() }
    });

    if (!ormEntity) return null;

    // 2. Conversion ORM ‚Üí Domain via Mapper
    return UserOrmMapper.toDomainEntity(ormEntity);
  }

  async findAll(criteria: UserCriteria): Promise<User[]> {
    // 1. Requ√™te ORM avec crit√®res
    const ormEntities = await this.repository.find(/* crit√®res */);

    // 2. Conversion batch via Mapper
    return UserOrmMapper.toDomainEntities(ormEntities);
  }
}
```

### üö® **ERREURS COURANTES √Ä √âVITER**

#### **‚ùå Import Domain dans Entit√© ORM**
```typescript
// VIOLATION - Ne jamais importer Domain dans ORM
import { User } from '../../../domain/entities/user.entity'; // INTERDIT !

@Entity('users')
export class UserOrmEntity {
  // Cette entit√© ne doit conna√Ætre QUE TypeORM
}
```

#### **‚ùå Logique M√©tier dans Mapper**
```typescript
// VIOLATION - Mapper ne doit contenir QUE de la conversion
static toDomainEntity(orm: UserOrmEntity): User {
  const email = Email.create(orm.email);

  // ‚ùå INTERDIT - Pas de logique m√©tier dans mapper
  if (email.getValue().includes('admin')) {
    user.grantAdminRights(); // VIOLATION !
  }

  return user;
}
```

#### **‚ùå Conversion Directe sans Mapper**
```typescript
// VIOLATION - Toujours passer par le mapper
async save(user: User): Promise<User> {
  // ‚ùå INTERDIT - Conversion manuelle
  const ormEntity = new UserOrmEntity();
  ormEntity.email = user.getEmail().getValue(); // VIOLATION !

  // ‚úÖ CORRECT - Utiliser le mapper
  const ormEntity = UserOrmMapper.toOrmEntity(user);
}
```

### üìã **CHECKLIST MAPPERS OBLIGATOIRE**

- [ ] ‚úÖ **Z√©ro m√©thode de mapping dans entit√©s ORM**
- [ ] ‚úÖ **Mappers d√©di√©s dans `/infrastructure/mappers/`**
- [ ] ‚úÖ **M√©thodes statiques `toOrmEntity()` et `toDomainEntity()`**
- [ ] ‚úÖ **Support des collections avec `toDomainEntities()`**
- [ ] ‚úÖ **Aucun import Domain dans entit√©s ORM**
- [ ] ‚úÖ **Aucune logique m√©tier dans mappers**
- [ ] ‚úÖ **Validation par les tests unitaires des mappers**
- [ ] ‚úÖ **Export centralis√© dans `orm-mappers.ts`**

### üéØ **TESTS UNITAIRES MAPPERS OBLIGATOIRES**

```typescript
// ‚úÖ Tests complets pour chaque mapper
describe('UserOrmMapper', () => {
  describe('toDomainEntity', () => {
    it('should convert ORM entity to Domain entity', () => {
      // Given
      const ormEntity = createValidUserOrmEntity();

      // When
      const domainEntity = UserOrmMapper.toDomainEntity(ormEntity);

      // Then
      expect(domainEntity).toBeInstanceOf(User);
      expect(domainEntity.getEmail().getValue()).toBe(ormEntity.email);
    });

    it('should handle null values correctly', () => {
      // Test des cas limites et valeurs nulles
    });
  });

  describe('toOrmEntity', () => {
    it('should convert Domain entity to ORM entity', () => {
      // Test de la conversion inverse
    });
  });

  describe('toDomainEntities', () => {
    it('should convert array of ORM entities', () => {
      // Test des collections
    });
  });
});
```

**Cette s√©paration stricte garantit une architecture propre, maintenable et respectueuse des principes de Clean Architecture !**

## üìö **DOCUMENTATION SWAGGER - BONNES PRATIQUES OBLIGATOIRES**

### üéØ **R√àGLE CRITIQUE : DOCUMENTATION SWAGGER COMPL√àTE APR√àS PR√âSENTATION**

**Apr√®s avoir cr√©√© les Controllers et DTOs, TOUJOURS cr√©er une documentation Swagger compl√®te pour garantir une API utilisable et professionnelle.**

#### **üìã Template de Documentation Swagger Obligatoire**

```markdown
# üéØ {FeatureName} APIs - Swagger Documentation

## üìã Overview
Description claire de la fonctionnalit√© et de ses APIs

## üèóÔ∏è Architecture Implementation Status
### ‚úÖ **{FeatureName} - 100% Complete**
- **Domain** : ‚úÖ {Entity} Entity + Value Objects + Repository Interface
- **Application** : ‚úÖ All CRUD Use Cases (Create, Get, Update, Delete, List)
- **Infrastructure** : ‚úÖ {Entity}OrmEntity + TypeOrm{Entity}Repository + Mappers + Migration
- **Presentation** : ‚úÖ {Entity}Controller + All DTOs with Swagger documentation

## üéØ {FeatureName} APIs

### **POST /api/v1/{resources}/list**
**Description** : Recherche avanc√©e pagin√©e
**Security** : Requires JWT authentication
**Request Body** : [Example with all fields]
**Response** : [Complete response with pagination metadata]

### **GET /api/v1/{resources}/:id**
**Description** : R√©cup√©rer par ID
**Response** : [Complete entity response]

### **POST /api/v1/{resources}**
**Description** : Cr√©er nouveau
**Request Body** : [All required and optional fields with validation rules]

### **PUT /api/v1/{resources}/:id**
**Description** : Mettre √† jour
**Request Body** : [Partial update examples]

### **DELETE /api/v1/{resources}/:id**
**Description** : Supprimer
**Response** : [Deletion confirmation]

## üö® Error Responses
Format d'erreur standardis√© avec tous les codes HTTP possibles

## üîê Authentication & Authorization
JWT + permissions requises

## üìä Validation Rules
Toutes les r√®gles de validation expliqu√©es

## üéØ Business Rules
R√®gles m√©tier sp√©cifiques √† la fonctionnalit√©

## üìà Performance & Scalability
Pagination, cache, performance

## üîß Swagger Integration
URLs et fonctionnalit√©s Swagger disponibles
```

#### **üîß Configuration Swagger Correcte dans les DTOs**

```typescript
// ‚úÖ OBLIGATOIRE - Schema objects avec additionalProperties
@ApiPropertyOptional({
  description: 'Configuration object',
  type: 'object',
  additionalProperties: true, // ‚ö†Ô∏è REQUIS pour √©viter erreurs TypeScript
})
readonly configObject?: any;

// ‚úÖ OBLIGATOIRE - Response DTOs avec d√©finite assignment
export class ResponseDto {
  @ApiProperty()
  readonly success!: boolean; // ‚ö†Ô∏è ! REQUIS pour √©viter erreurs TypeScript

  @ApiProperty({ type: 'array', items: { type: 'object' } })
  readonly data!: any[]; // ‚ö†Ô∏è ! REQUIS
}

// ‚úÖ OBLIGATOIRE - Enum documentation compl√®te
@ApiPropertyOptional({
  description: 'Status filter',
  enum: ['ACTIVE', 'INACTIVE', 'ON_LEAVE', 'SUSPENDED'],
  example: 'ACTIVE'
})
@IsOptional()
@IsString()
readonly status?: string;
```

#### **üéØ Controllers avec Documentation Swagger Optimale**

```typescript
// ‚úÖ OBLIGATOIRE - Tags et descriptions compl√®tes
@ApiTags('üë• {FeatureName} Management')
@Controller('api/v1/{resources}')
@ApiBearerAuth()
export class {Feature}Controller {

  // ‚úÖ OBLIGATOIRE - Documentation compl√®te avec exemples
  @Post('list')
  @ApiOperation({
    summary: 'üîç Search {resources} with advanced filters',
    description: `
    Recherche avanc√©e pagin√©e des {resources}.

    ‚úÖ Fonctionnalit√©s :
    - Pagination (page, limit)
    - Tri multi-crit√®res (sortBy, sortOrder)
    - Recherche textuelle (search)
    - Filtres sp√©cialis√©s ({specific filters})

    üîê Permissions requises :
    - MANAGE_{RESOURCES} ou READ_{RESOURCES}
    - Scoping automatique selon r√¥le utilisateur
    `,
  })
  @ApiResponse({
    status: HttpStatus.OK,
    description: '‚úÖ {Resources} found successfully',
    type: List{Resource}ResponseDto,
  })
  @ApiResponse({
    status: HttpStatus.BAD_REQUEST,
    description: '‚ùå Invalid search parameters',
  })
  @ApiResponse({
    status: HttpStatus.UNAUTHORIZED,
    description: 'üîê Authentication required',
  })
  @ApiResponse({
    status: HttpStatus.FORBIDDEN,
    description: 'üö´ Insufficient permissions',
  })
  async list(@Body() dto: List{Resource}sDto, @GetUser() user: User) {
    // Implementation
  }
}
```

#### **üö® Erreurs Swagger Courantes √† √âviter**

1. **‚ùå Schema objects sans additionalProperties**
```typescript
// INTERDIT - Cause des erreurs TypeScript
@ApiPropertyOptional({
  type: 'object', // Manque additionalProperties: true
})
```

2. **‚ùå Response DTOs sans definite assignment**
```typescript
// INTERDIT - Cause des erreurs TypeScript strictes
export class ResponseDto {
  readonly success: boolean; // Manque !
}
```

3. **‚ùå Documentation API incompl√®te**
```typescript
// INTERDIT - Documentation minimale
@ApiOperation({ summary: 'Get data' }) // Trop vague
```

4. **‚ùå Enums non document√©s**
```typescript
// INTERDIT - Valeurs enum non expos√©es
@IsEnum(StaffRole) // Manque documentation Swagger
```

#### **üìÅ Structure Documentation Obligatoire**

```
docs/
‚îú‚îÄ‚îÄ SWAGGER_{FEATURE}_API.md     # Documentation compl√®te par fonctionnalit√©
‚îú‚îÄ‚îÄ SWAGGER_ENHANCEMENT_REPORT.md # Rapport d'am√©lioration Swagger
‚îî‚îÄ‚îÄ API_STANDARDS.md             # Standards g√©n√©raux API
```

#### **‚úÖ Checklist Swagger Obligatoire**

- [ ] **Documentation markdown** compl√®te cr√©√©e dans `/docs/`
- [ ] **Tous les endpoints** document√©s avec exemples
- [ ] **Request/Response** schemas complets avec validation
- [ ] **Error responses** avec codes HTTP appropri√©s
- [ ] **Authentication** et permissions document√©es
- [ ] **Business rules** expliqu√©es clairement
- [ ] **Swagger UI** accessible sur `/api/docs`
- [ ] **DTOs** avec `additionalProperties: true` pour objects
- [ ] **Response DTOs** avec definite assignment (`!`)
- [ ] **Enums** document√©s avec toutes les valeurs possibles
- [ ] **Controllers** avec `@ApiOperation` d√©taill√©es

### üéØ **Workflow Complet : Pr√©sentation + Swagger**

1. **Cr√©er Controllers + DTOs** (couche Presentation)
2. **Tester et corriger** erreurs TypeScript/lint
3. **Cr√©er documentation Swagger** markdown compl√®te
4. **V√©rifier Swagger UI** fonctionnel
5. **Tester APIs** via Swagger interface
6. **Valider examples** et sch√©mas complets
7. **Mettre √† jour** architecture status

**Cette approche garantit des APIs professionnelles, document√©es et facilement utilisables !**

### üíé **VALUE OBJECTS - BONNES PRATIQUES DANS LES MAPPERS**

#### **üéØ R√àGLE IMPORTANTE : RECONSTRUCTION CORRECTE DES VALUE OBJECTS**

Les Value Objects doivent √™tre correctement reconstruits dans les mappers en utilisant les bonnes m√©thodes factory :

```typescript
// ‚úÖ EXCELLENT - Reconstruction correcte des Value Objects
export class UserOrmMapper {
  static toDomainEntity(orm: UserOrmEntity): User {
    // ‚úÖ Utilisation des m√©thodes factory appropri√©es
    const userId = UserId.fromString(orm.id);
    const email = Email.create(orm.email); // Pour validation
    const phone = orm.phone ? Phone.create(orm.phone) : undefined;

    return User.reconstruct({
      id: userId,
      email: email,
      name: orm.name,
      phone: phone,
      createdAt: orm.created_at,
      updatedAt: orm.updated_at,
    });
  }

  static toOrmEntity(domain: User): UserOrmEntity {
    const orm = new UserOrmEntity();

    // ‚úÖ Extraction des valeurs primitives
    orm.id = domain.getId().getValue();
    orm.email = domain.getEmail().getValue();
    orm.name = domain.getName();
    orm.phone = domain.getPhone()?.getValue();
    orm.created_at = domain.getCreatedAt();
    orm.updated_at = domain.getUpdatedAt();

    return orm;
  }
}
```

#### **üö® ERREURS COURANTES AVEC VALUE OBJECTS**

```typescript
// ‚ùå INTERDIT - Construction directe sans validation
const email = new Email(orm.email); // VIOLATION !

// ‚úÖ CORRECT - Utilisation de la m√©thode factory
const email = Email.create(orm.email); // Validation automatique

// ‚ùå INTERDIT - Reconstruction incorrecte d'ID
const userId = new UserId(orm.id); // VIOLATION !

// ‚úÖ CORRECT - M√©thode factory appropri√©e
const userId = UserId.fromString(orm.id); // Type-safe

// ‚ùå INTERDIT - Gestion incorrecte des nullable
const phone = Phone.create(orm.phone); // Peut planter si null !

// ‚úÖ CORRECT - Gestion s√©curis√©e des nullable
const phone = orm.phone ? Phone.create(orm.phone) : undefined;
```

#### **üìã MAPPING PATTERNS PAR TYPE DE VALUE OBJECT**

```typescript
// üÜî ID Value Objects
const userId = UserId.fromString(orm.user_id);
const businessId = BusinessId.fromString(orm.business_id);
const serviceId = ServiceId.fromString(orm.service_id);

// üìß Email (avec validation)
const email = Email.create(orm.email);

// üì± Phone (nullable)
const phone = orm.phone ? Phone.create(orm.phone) : undefined;

// üí∞ Money (complexe)
const price = Money.create(orm.price_amount, orm.price_currency);

// üåê URL (avec validation)
const profileImage = orm.profile_image_url
  ? FileUrl.create(orm.profile_image_url)
  : undefined;

// üìÖ Dates (primitives)
const createdAt = orm.created_at; // Date directe
const updatedAt = orm.updated_at; // Date directe
```

#### **‚úÖ TEMPLATE MAPPER STANDARD**

```typescript
export class {Entity}OrmMapper {
  static toDomainEntity(orm: {Entity}OrmEntity): {Entity} {
    // 1. Reconstruction des Value Objects avec validation
    const id = {Entity}Id.fromString(orm.id);
    const email = Email.create(orm.email);
    const phone = orm.phone ? Phone.create(orm.phone) : undefined;

    // 2. Reconstruction de l'entit√© Domain
    return {Entity}.reconstruct({
      id,
      email,
      phone,
      // Autres propri√©t√©s...
      createdAt: orm.created_at,
      updatedAt: orm.updated_at,
    });
  }

  static toOrmEntity(domain: {Entity}): {Entity}OrmEntity {
    const orm = new {Entity}OrmEntity();

    // 1. Extraction des valeurs primitives
    orm.id = domain.getId().getValue();
    orm.email = domain.getEmail().getValue();
    orm.phone = domain.getPhone()?.getValue();

    // 2. Dates et primitives directes
    orm.created_at = domain.getCreatedAt();
    orm.updated_at = domain.getUpdatedAt();

    return orm;
  }

  static toDomainEntities(ormList: {Entity}OrmEntity[]): {Entity}[] {
    return ormList.map(orm => this.toDomainEntity(orm));
  }
}
```

### üèóÔ∏è **Les 4 Couches Principales**

#### 1. üèõÔ∏è **Entities (Entit√©s)**

- **R√¥le** : Encapsulent les r√®gles m√©tier de l'enterprise
- **Contenu** : Objets avec m√©thodes OU structures de donn√©es + fonctions
- **Stabilit√©** : Les moins susceptibles de changer lors de changements externes
- **Exemple** : Pas affect√©es par les changements de navigation, s√©curit√©, ou UI

#### 2. üíº **Use Cases (Cas d'Usage)**

- **R√¥le** : Contiennent les r√®gles m√©tier sp√©cifiques √† l'application
- **Contenu** : Orchestrent le flux de donn√©es vers/depuis les entit√©s
- **Isolation** : Isol√©es des pr√©occupations externes (DB, UI, frameworks)
- **Impact** : Affect√©es uniquement par les changements d'op√©rations applicatives

#### 3. üîå **Interface Adapters (Adaptateurs d'Interface)**

- **R√¥le** : Ensemble d'adaptateurs qui convertissent les donn√©es
- **Contenu** : MVC, Presenters, Views, Controllers, Repository implementations
- **Conversion** : Du format le plus pratique pour use cases/entities vers le format externe
- **Exemple** : Tout le SQL doit √™tre restreint √† cette couche

#### 4. üîß **Frameworks and Drivers (Frameworks et Pilotes)**

- **R√¥le** : Couche la plus externe compos√©e de frameworks et outils
- **Contenu** : Database, Web Framework, outils externes
- **Code** : Principalement du code de "glue" qui communique vers l'int√©rieur
- **D√©tails** : O√π tous les d√©tails vont (Web, Database sont des d√©tails)

### üö™ **Crossing Boundaries (Franchissement des Fronti√®res)**

#### üîÑ **Dependency Inversion Principle**

- **Probl√®me** : Use case doit appeler presenter, mais ne peut pas (violation de Dependency Rule)
- **Solution** : Use case appelle une interface dans le cercle int√©rieur
- **Impl√©mentation** : Presenter dans cercle ext√©rieur impl√©mente l'interface
- **Technique** : Polymorphisme dynamique pour cr√©er des d√©pendances qui s'opposent au flux de contr√¥le

#### üì¶ **Data Crossing Boundaries**

- **Format** : Structures de donn√©es simples et isol√©es
- **Types autoris√©s** : Structs basiques, Data Transfer Objects, arguments de fonctions
- **‚ùå INTERDIT** : Passer des Entities ou Database rows √† travers les fronti√®res
- **‚ùå INTERDIT** : Structures de donn√©es avec d√©pendances violant la Dependency Rule
- **‚úÖ R√àGLE** : Donn√©es toujours dans le format le plus pratique pour le cercle int√©rieur

## üìù **Commits S√©mantiques OBLIGATOIRES**

### üéØ **Conventional Commits avec Commitlint**

Ce projet utilise **[Commitlint](https://github.com/conventional-changelog/commitlint/#what-is-commitlint)** pour garantir des commits s√©mantiques et conventionnels standardis√©s.

#### **‚úÖ Format OBLIGATOIRE**

```
üéØ type(scope): description

body (optionnel)

footer (optionnel)
```

#### **üè∑Ô∏è Types de Commits AUTORIS√âS**

- üéâ **feat**: Nouvelle fonctionnalit√©
- üêõ **fix**: Correction de bug
- üìö **docs**: Documentation
- üíÑ **style**: Formatage, point-virgules, etc. (pas de changement de code)
- ‚ôªÔ∏è **refactor**: Refactoring (ni feature ni fix)
- ‚ö° **perf**: Am√©lioration des performances
- ‚úÖ **test**: Ajout/modification de tests
- üîß **chore**: T√¢ches de maintenance, outils, etc.
- üöÄ **ci**: Configuration CI/CD
- ‚è™ **revert**: Annulation d'un commit pr√©c√©dent
- üîê **security**: Corrections de s√©curit√©
- üåê **i18n**: Internationalisation
- ‚ôø **a11y**: Accessibilit√©
- üö® **hotfix**: Correction urgente en production

#### **üìã Exemples de Commits Valides**

```bash
üéâ feat(auth): add JWT refresh token rotation
üêõ fix(user): resolve email validation edge case
üìö docs(api): update authentication endpoints documentation
‚ôªÔ∏è refactor(repo): extract common repository patterns
‚úÖ test(login): add comprehensive login use case tests
üîß chore(deps): update NestJS to latest version
üîê security(jwt): implement secure token storage
```

#### **‚ùå Commits INTERDITS**

```bash
# Trop vague
fix: bug fix
update code
improvements

# Type non autoris√©
hack: quick fix
temp: temporary solution
```

#### **üéØ R√®gles Commitlint Configur√©es**

```javascript
// .commitlintrc.js
{
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [2, 'always', [
      'üéâ feat', 'üêõ fix', 'üìö docs', 'üíÑ style',
      '‚ôªÔ∏è refactor', '‚ö° perf', '‚úÖ test', 'üîß chore',
      'üöÄ ci', '‚è™ revert', 'üîê security', 'üåê i18n',
      '‚ôø a11y', 'üö® hotfix'
    ]],
    'subject-case': [2, 'never', ['sentence-case', 'start-case', 'pascal-case', 'upper-case']],
    'subject-empty': [2, 'never'],
    'subject-full-stop': [2, 'never', '.'],
    'body-leading-blank': [1, 'always'],
    'body-max-line-length': [2, 'always', 100],
    'footer-leading-blank': [1, 'always'],
    'header-max-length': [2, 'always', 100]
  }
}
```

**üöÄ NOUVEAUT√â : Environnement Docker Complet**

### ÔøΩ **Docker Environment Production-Ready**

- ‚úÖ **Docker Compose** multi-services avec hot reload
- ‚úÖ **PostgreSQL 15** avec volume persistant et health checks
- ‚úÖ **MongoDB 7** pour stockage NoSQL avec r√©plication
- ‚úÖ **pgAdmin 4** interface web pour gestion PostgreSQL (localhost:5050)
- ‚úÖ **NestJS** containeris√© avec debug ports et volumes
- ‚úÖ **Makefile** complet avec commandes Docker simplifi√©es

#### **üîß Commandes Docker Disponibles**

```bash
make start          # D√©marrer tous les services Docker
make stop           # Arr√™ter tous les services
make build          # Construire les images Docker
make logs           # Voir les logs de tous les services
make test           # Lancer les tests dans le container
make clean          # Nettoyer volumes et images
make restart        # Red√©marrer les services
make status         # Statut des services
```

### üìä **M√©triques de Qualit√© Am√©lior√©es**

### üéØ **Objectifs Maintenus et Am√©lior√©s**

- ‚úÖ **202 tests** passants (30 suites de tests compl√®tes) - **UPGRADE de 24 tests**
- ‚úÖ **Clean Architecture** respect√©e dans tous les composants
- ‚úÖ **SOLID principles** appliqu√©s rigoureusement
- ‚úÖ **Security first** approach avec cookies HttpOnly
- ‚úÖ **Enterprise patterns** utilis√©s (logging, audit, i18n)
- ‚úÖ **Docker environment** pour d√©veloppement isol√©
- ‚úÖ **ESLint errors ELIMINATED** - De 18 erreurs bloquantes √† 0 üéØ‚ú®
- ‚úÖ **Node.js 24 Ready** - Architecture compatible nouvelles fonctionnalit√©s
- ‚úÖ **Code quality** avec ESLint + Prettier configur√©s strictement

### üìà **Indicateurs de Succ√®s - MISE √Ä JOUR FINALE**

- Tests continuent de passer apr√®s modifications (198/198 ‚úÖ)
- **üéØ Z√âRO ERREUR ESLINT BLOQUANTE** - 100% des erreurs critiques √©limin√©es
- **Promise.all corrections** - M√©thodes synchrones converties en Promises
- **Regex patterns optimized** - √âchappements inutiles supprim√©s (no-useless-escape)
- **Enum comparisons fixed** - Type safety renforc√© (no-unsafe-enum-comparison)
- **Case declarations wrapped** - Blocs correctement structur√©s (no-case-declarations)
- **Template expressions secured** - Types never correctement g√©r√©s
- Aucune d√©pendance circulaire introduite
- Logging et audit trail pr√©sents sur toutes les op√©rations
- Configuration externalis√©e (JWT secrets, expiration)
- Messages i18n utilis√©s dans tous les Use Cases
- Permissions v√©rifi√©es et exceptions sp√©cifiques
- Environnement Docker compl√®tement fonctionnel
- **Pipeline de qualit√© ESLint** op√©rationnel sans erreurs bloquantes

## üèóÔ∏è **Architecture √âtablie**

### üìÅ **Structure des Couches**

```
src/
‚îú‚îÄ‚îÄ domain/           # üè¢ R√®gles m√©tier pures (entities, value objects)
‚îú‚îÄ‚îÄ application/      # üíº Use cases + ports + exceptions applicatives
‚îú‚îÄ‚îÄ infrastructure/   # üîß Impl√©mentations techniques (repos, services)
‚îú‚îÄ‚îÄ presentation/     # üé® Controllers HTTP + DTOs
‚îî‚îÄ‚îÄ shared/           # üîó Cross-cutting concerns
```

### üéØ **Principes √† Respecter**

- ‚úÖ **Dependency Inversion** : Couches sup√©rieures ne d√©pendent jamais des inf√©rieures
- ‚úÖ **Single Responsibility** : Chaque classe a une seule responsabilit√©
- ‚úÖ **TDD First** : Tests avant impl√©mentation (**24 tests auth + autres**)
- ‚úÖ **Clean Code** : Nommage expressif, fonctions courtes, commentaires utiles
- ‚úÖ **Enterprise Security** : Authentification, autorizations, audit trail
- ‚úÖ **SOLID Principles** : Application rigoureuse des 5 principes de Robert C. Martin
- ‚úÖ **TypeScript Strict** : Type safety √† 100%, z√©ro tol√©rance pour `any`

## üéØ **Principes SOLID de Robert C. Martin**

### üîπ **S** - Single Responsibility Principle (SRP)

**Une classe, une seule raison de changer**

```typescript
// ‚úÖ GOOD - Une seule responsabilit√©
export class CreateUserUseCase {
  async execute(request: CreateUserRequest): Promise<CreateUserResponse> {
    // G√®re uniquement la cr√©ation d'utilisateur
  }
}

// ‚ùå BAD - Multiples responsabilit√©s
export class UserService {
  createUser() {} // Cr√©ation utilisateur
  sendEmail() {} // Envoi email
  validateData() {} // Validation donn√©es
}
```

### üîπ **O** - Open/Closed Principle (OCP)

**Ouvert √† l'extension, ferm√© √† la modification**

```typescript
// ‚úÖ GOOD - Extension via interfaces
export interface INotificationService {
  send(message: string, recipient: string): Promise<void>;
}

export class EmailNotificationService implements INotificationService {
  async send(message: string, recipient: string): Promise<void> {
    // Impl√©mentation email
  }
}

export class SmsNotificationService implements INotificationService {
  async send(message: string, recipient: string): Promise<void> {
    // Impl√©mentation SMS - extension sans modification
  }
}
```

### üîπ **L** - Liskov Substitution Principle (LSP)

**Les sous-types doivent √™tre substituables √† leurs types de base**

```typescript
// ‚úÖ GOOD - Substitution correcte
export abstract class Repository<T> {
  abstract save(entity: T): Promise<T>;
  abstract findById(id: string): Promise<T | null>;
}

export class UserRepository extends Repository<User> {
  async save(user: User): Promise<User> {
    // Respecte le contrat - retourne toujours un User
    return this.persistenceAdapter.save(user);
  }

  async findById(id: string): Promise<User | null> {
    // Respecte le contrat - retourne User ou null
    return this.persistenceAdapter.findById(id);
  }
}
```

### üîπ **I** - Interface Segregation Principle (ISP)

**Les clients ne doivent pas d√©pendre d'interfaces qu'ils n'utilisent pas**

```typescript
// ‚úÖ GOOD - Interfaces s√©gr√©g√©es
export interface IUserReader {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
}

export interface IUserWriter {
  save(user: User): Promise<User>;
  delete(id: string): Promise<void>;
}

export interface IUserCounter {
  count(): Promise<number>;
  countByRole(role: UserRole): Promise<number>;
}

// ‚ùå BAD - Fat interface
export interface IUserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<User>;
  delete(id: string): Promise<void>;
  count(): Promise<number>;
  exportToJson(): Promise<string>; // Non utilis√© par tous
  generateReport(): Promise<Buffer>; // Non utilis√© par tous
}
```

### üîπ **D** - Dependency Inversion Principle (DIP)

**D√©pendre des abstractions, pas des impl√©mentations**

```typescript
// ‚úÖ GOOD - D√©pend des abstractions
export class CreateUserUseCase {
  constructor(
    private readonly userRepository: IUserRepository, // Interface
    private readonly logger: ILogger, // Interface
    private readonly eventBus: IEventBus, // Interface
  ) {}
}

// ‚ùå BAD - D√©pend des impl√©mentations
export class CreateUserUseCase {
  constructor(
    private readonly userRepository: TypeOrmUserRepository, // Classe concr√®te
    private readonly logger: ConsoleLogger, // Classe concr√®te
    private readonly eventBus: InMemoryEventBus, // Classe concr√®te
  ) {}
}
```

## üîß **Meilleures Pratiques TypeScript**

### üéØ **Configuration Stricte Obligatoire**

```typescript
// tsconfig.json - Mode strict OBLIGATOIRE
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true
  }
}
```

### üéØ **Typage Explicite - ZERO `any` - PR√âF√âRER `unknown`**

```typescript
// ‚úÖ GOOD - Types explicites pour APIs publiques et unknown pour types incertains
export interface CreateUserRequest {
  readonly email: string;
  readonly name: string;
  readonly role: UserRole;
  readonly requestingUserId: string;
}

export interface CreateUserResponse {
  readonly id: string;
  readonly email: string;
  readonly name: string;
  readonly role: UserRole;
  readonly createdAt: Date;
}

// ‚úÖ GOOD - Contraintes g√©n√©riques
export interface Repository<T extends Entity> {
  save(entity: T): Promise<T>;
  findById(id: string): Promise<T | null>;
}

// ‚úÖ GOOD - Union types pour valeurs contr√¥l√©es
export type DatabaseType = 'mongodb' | 'postgresql' | 'mysql';
export type Environment = 'development' | 'staging' | 'production';

// ‚ùå STRICTEMENT INTERDIT - Usage de any
export function processData(data: any): any {
  // JAMAIS ! Utilise unknown √† la place
  return data;
}

// ‚úÖ EXCELLENT - Utiliser unknown au lieu de any
export function processData(data: unknown): unknown {
  // Type guard OBLIGATOIRE avec unknown
  if (typeof data === 'object' && data !== null) {
    return data;
  }
  throw new Error('Invalid data type');
}

// ‚úÖ MEILLEUR - Types sp√©cifiques avec g√©n√©rique
export function processData<T>(data: T): T {
  return data;
}

// ‚úÖ PATTERN RECOMMAND√â - Type guards avec unknown
function isValidUser(data: unknown): data is User {
  return (
    typeof data === 'object' &&
    data !== null &&
    'id' in data &&
    'email' in data &&
    typeof (data as { id: unknown }).id === 'string' &&
    typeof (data as { email: unknown }).email === 'string'
  );
}

// ‚úÖ PATTERN RECOMMAND√â - Parsing s√©curis√© avec unknown
export function parseUserFromRequest(req: unknown): User {
  if (!isValidUser(req)) {
    throw new ValidationError('Invalid user data structure');
  }
  return req; // TypeScript sait maintenant que c'est un User
}

// ‚úÖ PATTERN RECOMMAND√â - API Responses typ√©es
export interface SafeApiResponse<T = unknown> {
  readonly success: boolean;
  readonly data: T;
  readonly errors?: readonly string[];
  readonly meta?: {
    readonly timestamp: string;
    readonly requestId: string;
  };
}

// ‚ùå ANTI-PATTERNS √Ä √âVITER
// Ne jamais utiliser : as any, any[], Array<any>, Record<string, any>
// Ne jamais typer les param√®tres de requ√™te comme any
// Ne jamais retourner any depuis une fonction publique
```

### üö® **R√àGLES STRICTES DE TYPAGE**

#### **üî¥ INTERDICTIONS ABSOLUES**

- **`any`** : Usage strictement interdit sauf cas exceptionnels document√©s
- **`as any`** : Casting dangereux interdit
- **`any[]`** : Tableaux non typ√©s interdits
- **`Record<string, any>`** : Objets non typ√©s interdits
- **`function(param: any)`** : Param√®tres non typ√©s interdits

#### **üü¢ ALTERNATIVES RECOMMAND√âES**

- **`unknown`** : Pour types incertains n√©cessitant type guards
- **`object`** : Pour objets g√©n√©riques
- **`Record<string, unknown>`** : Pour objets avec cl√©s dynamiques
- **Generics `<T>`** : Pour types param√©tr√©s
- **Union types** : Pour valeurs connues limit√©es
- **Type guards** : Pour validation runtime des types

### üéØ **Gestion Null-Safe & Erreurs**

```typescript
// ‚úÖ GOOD - Gestion explicite des null
export class UserService {
  async findUserById(id: string): Promise<User | null> {
    const userData = await this.repository.findById(id);
    return userData ? User.fromData(userData) : null;
  }

  async getUserById(id: string): Promise<User> {
    const user = await this.findUserById(id);
    if (!user) {
      throw new UserNotFoundError(`User with id ${id} not found`);
    }
    return user;
  }
}

// ‚úÖ GOOD - Result pattern pour gestion d'erreurs
export type Result<T, E = Error> =
  | { success: true; data: T }
  | { success: false; error: E };

export async function safeOperation<T>(
  operation: () => Promise<T>,
): Promise<Result<T>> {
  try {
    const data = await operation();
    return { success: true, data };
  } catch (error) {
    return { success: false, error: error as Error };
  }
}
```

## üîç **ESLint & Formatage - R√®gles CRITIQUES**

### üéØ **R√®gles NON D√âSACTIVABLES**

```typescript
// eslint.config.mjs
export default [
  {
    rules: {
      // Type Safety - CRITIQUE
      '@typescript-eslint/no-any': 'error',
      '@typescript-eslint/no-explicit-any': 'error',
      '@typescript-eslint/no-unsafe-assignment': 'error',
      '@typescript-eslint/no-unsafe-call': 'error',
      '@typescript-eslint/no-unsafe-member-access': 'error',
      '@typescript-eslint/no-unsafe-return': 'error',

      // Qualit√© Code - CRITIQUE
      '@typescript-eslint/no-unused-vars': 'error',
      '@typescript-eslint/prefer-readonly': 'error',
      '@typescript-eslint/explicit-function-return-type': 'error',
      '@typescript-eslint/no-inferrable-types': 'off', // Pr√©f√©rer explicite

      // Bonnes Pratiques - CRITIQUE
      '@typescript-eslint/await-thenable': 'error',
      '@typescript-eslint/require-await': 'error',
      '@typescript-eslint/no-floating-promises': 'error',
    },
  },
];
```

### üéØ **Configuration Prettier Standardis√©e**

```json
// .prettierrc
{
  "semi": true,
  "trailingComma": "all",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "bracketSpacing": true,
  "arrowParens": "avoid"
}
```

## üö® **ERREURS ESLINT CRITIQUES IDENTIFI√âES - MISE √Ä JOUR POST-MIGRATION**

### üéØ **PROBL√àMES URGENTS √Ä CORRIGER DANS L'ORDRE DE PRIORIT√â**

#### **1Ô∏è‚É£ PRIORIT√â MAXIMALE : @typescript-eslint/no-unsafe-*** (1437 warnings)**

**‚ùå PROBL√àME CRITIQUE** : Usage intensif de `any` √† travers le codebase causant des violations de type safety.

**üèóÔ∏è LOCALISATION PRINCIPALE :**

```typescript
// ‚ùå VIOLATIONS MAJEURES D√âTECT√âES dans :
// - src/presentation/controllers/*.controller.ts
// - src/presentation/dtos/*.dto.ts
// - src/presentation/filters/*.filter.ts
// - src/presentation/security/*.ts
// - src/shared/utils/*.ts

// Exemple de violation courante dans controllers :
// ‚ùå INTERDIT - Acc√®s non typ√© aux propri√©t√©s de requ√™te
const requestingUser = req.user; // any type !
const userId = requestingUser.id; // Unsafe member access

// ‚úÖ CORRECT - Typage strict obligatoire
const requestingUser = req.user as AuthenticatedUser;
const userId: string = requestingUser.id;

// OU MIEUX - Interface typ√©e
interface AuthenticatedRequest extends Request {
  user: AuthenticatedUser;
}
```

#### **2Ô∏è‚É£ PRIORIT√â √âLEV√âE : @typescript-eslint/require-await (8 violations)**

**‚ùå PROBL√àME** : M√©thodes marqu√©es `async` sans utilisation d'`await`.

```typescript
// ‚ùå VIOLATIONS D√âTECT√âES dans :
// - business.controller.ts:468 - async delete() sans await
// - calendar.controller.ts:330 - async update() sans await
// - calendar.controller.ts:379 - async delete() sans await

// ‚ùå INTERDIT - async sans await
async delete(id: string): Promise<void> {
  // Pas d'await dans cette m√©thode
  this.businessService.delete(id);
}

// ‚úÖ CORRECT - Ajouter await OU enlever async
async delete(id: string): Promise<void> {
  await this.businessService.delete(id);
}

// OU
delete(id: string): Promise<void> {
  return this.businessService.delete(id);
}
```

#### **3Ô∏è‚É£ PRIORIT√â √âLEV√âE : @typescript-eslint/no-unused-vars (4 violations)**

**‚ùå PROBL√àME** : Variables d√©clar√©es mais jamais utilis√©es.

```typescript
// ‚ùå VIOLATIONS D√âTECT√âES dans :
// - business-hours.controller.ts:323 - 'user' d√©fini mais inutilis√©
// - calendar.controller.ts:331 - 'id' d√©fini mais inutilis√©
// - calendar.controller.ts:332 - 'dto' d√©fini mais inutilis√©
// - calendar.controller.ts:379 - 'id' d√©fini mais inutilis√©

// ‚ùå INTERDIT - Variables inutilis√©es
async method(@GetUser() user: User, @Param('id') id: string) {
  // user et id jamais utilis√©s dans la m√©thode
  return { success: true };
}

// ‚úÖ CORRECT - Pr√©fixer avec underscore si requis par interface
async method(@GetUser() _user: User, @Param('id') _id: string) {
  // Indique explicitement que les param√®tres ne sont pas utilis√©s
  return { success: true };
}

// OU supprimer les param√®tres inutilis√©s
async method() {
  return { success: true };
}
```

#### **4Ô∏è‚É£ PRIORIT√â √âLEV√âE : @typescript-eslint/unbound-method (2 violations)**

**‚ùå PROBL√àME** : R√©f√©rences de m√©thodes sans liaison `this`.

```typescript
// ‚ùå VIOLATIONS D√âTECT√âES dans :
// - business-sector.mapper.ts:168 - r√©f√©rence m√©thode non li√©e
// - business-sector.mapper.ts:216 - r√©f√©rence m√©thode non li√©e

// ‚ùå INTERDIT - R√©f√©rence m√©thode sans this
const transformedData = data.map(this.transform); // Probl√®me de scoping

// ‚úÖ CORRECT - Arrow function
const transformedData = data.map(item => this.transform(item));

// OU liaison explicite
const transformedData = data.map(this.transform.bind(this));
```

### üîß **SOLUTIONS TECHNIQUES PRIORITAIRES**

#### **üéØ Solution 1 : Interfaces TypeScript Strictes**

```typescript
// ‚úÖ OBLIGATOIRE - Cr√©er des interfaces typ√©es pour les requ√™tes
export interface AuthenticatedRequest extends Request {
  user: AuthenticatedUser;
}

export interface AuthenticatedUser {
  id: string;
  email: string;
  role: UserRole;
  isActive: boolean;
  isVerified: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// ‚úÖ UTILISATION dans les controllers
@Controller('users')
export class UserController {
  @Get('profile')
  async getProfile(@Req() req: AuthenticatedRequest): Promise<UserDto> {
    const user = req.user; // Maintenant typ√© !
    const userId: string = user.id; // Type-safe
    return this.userService.getProfile(userId);
  }
}
```

#### **üéØ Solution 2 : D√©corateurs Typ√©s**

```typescript
// ‚úÖ OBLIGATOIRE - D√©corateur @GetUser typ√©
export const GetUser = createParamDecorator(
  (data: keyof AuthenticatedUser | undefined, ctx: ExecutionContext): AuthenticatedUser => {
    const request = ctx.switchToHttp().getRequest<AuthenticatedRequest>();
    const user = request.user;

    if (!data) return user;
    return user[data] as any; // Type guard n√©cessaire ici
  },
);

// ‚úÖ UTILISATION typ√©e
@Get('profile')
async getProfile(@GetUser() user: AuthenticatedUser): Promise<UserDto> {
  const userId: string = user.id; // Type-safe !
  return this.userService.getProfile(userId);
}
```

#### **üéØ Solution 3 : Transformers DTO Typ√©s**

```typescript
// ‚úÖ OBLIGATOIRE - Transformers avec typage strict
export class CreateBusinessSectorDto {
  @Transform(({ value }: { value: unknown }) => {
    if (typeof value !== 'string') {
      throw new ValidationError('Name must be a string');
    }
    return value.trim();
  })
  @IsString()
  @Length(2, 100)
  readonly name!: string;

  @Transform(({ value }: { value: unknown }) => {
    if (typeof value !== 'string') {
      throw new ValidationError('Code must be a string');
    }
    return value.trim().toUpperCase();
  })
  @IsString()
  @Length(2, 10)
  readonly code!: string;
}
```

### ‚ùå **Erreurs Promise.all avec m√©thodes synchrones**

```typescript
// ‚ùå INTERDIT - Promise.all avec des valeurs non-Promise
const [dbCheck, memoryInfo, systemInfo] = await Promise.all([
  this.checkDatabaseStatus(),  // OK - m√©thode async
  this.getMemoryInfo(),       // ‚ùå ERREUR - m√©thode synchrone
  this.getSystemInfo(),       // ‚ùå ERREUR - m√©thode synchrone
]);

// ‚úÖ CORRECT - Toutes les m√©thodes retournent des Promises
private getMemoryInfo(): Promise<MemoryInfo> {
  const memUsage = process.memoryUsage();
  return Promise.resolve({
    rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,
    heapTotal: `${Math.round(memUsage.heapTotal / 1024 / 1024)}MB`,
    heapUsed: `${Math.round(memUsage.heapUsed / 1024 / 1024)}MB`,
    external: `${Math.round(memUsage.external / 1024 / 1024)}MB`,
  });
}

private getSystemInfo(): Promise<SystemInfo> {
  return Promise.resolve({
    nodeVersion: process.version,
    platform: process.platform,
    arch: process.arch,
    cpuUsage: process.cpuUsage(),
    pid: process.pid,
  });
}
```

### ‚ùå **√âchappements inutiles dans les expressions r√©guli√®res**

```typescript
// ‚ùå INTERDIT - √âchappements inutiles
const phoneRegex = /^\+?[\d\s\-\(\)]{10,}$/;  // \-, \(, \) sont inutiles

// ‚úÖ CORRECT - √âchappements minimaux requis
const phoneRegex = /^\+?[\d\s-()]{10,}$/;     // Plus propre et correct
```

### ‚ùå **M√©thodes async sans await**

```typescript
// ‚ùå INTERDIT - async sans await
async generateTokens(userId: string): Promise<TokenPair> {
  // Pas d'await dans cette m√©thode
  return {
    accessToken: this.createAccessToken(userId),
    refreshToken: this.createRefreshToken(userId)
  };
}

// ‚úÖ CORRECT - Enlever async ou utiliser Promise.resolve
generateTokens(userId: string): Promise<TokenPair> {
  return Promise.resolve({
    accessToken: this.createAccessToken(userId),
    refreshToken: this.createRefreshToken(userId)
  });
}

// OU si vraiment besoin d'async
async generateTokens(userId: string): Promise<TokenPair> {
  const accessToken = await this.createAccessToken(userId);
  const refreshToken = await this.createRefreshToken(userId);
  return { accessToken, refreshToken };
}
```

### ‚ùå **Variables inutilis√©es (no-unused-vars)**

```typescript
// ‚ùå INTERDIT - Variables/imports non utilis√©s
import { Email, User, Permission } from '../domain/entities';  // Permission non utilis√©

export class CreateUserUseCase {
  execute(request: CreateUserRequest, context: AppContext): Promise<User> {
    // context n'est jamais utilis√© dans cette m√©thode
    const email = Email.create(request.email);
    return this.userRepository.save(User.create(email, request.name));
  }
}

// ‚úÖ CORRECT - Supprimer les imports/variables inutilis√©s
import { Email, User } from '../domain/entities';

export class CreateUserUseCase {
  execute(request: CreateUserRequest): Promise<User> {
    const email = Email.create(request.email);
    return this.userRepository.save(User.create(email, request.name));
  }
}

// ‚úÖ CORRECT - Pr√©fixer avec underscore si requis par interface
export class CreateUserUseCase {
  execute(request: CreateUserRequest, _context: AppContext): Promise<User> {
    // _context indique explicitement que le param√®tre n'est pas utilis√©
    const email = Email.create(request.email);
    return this.userRepository.save(User.create(email, request.name));
  }
}
```

### üéØ **R√®gles de Correction ESLint - MISE √Ä JOUR POST-MIGRATION**

#### **üö® PLAN D'ACTION CRITIQUE : √âliminer les 1437 warnings en 3 phases**

#### **PHASE 1 - CRITIQUE (1-2 jours) : Type Safety**

**1. @typescript-eslint/no-unsafe-assignment (PRIORIT√â MAX)**
- **Probl√®me** : `any` types causant des assignments non s√©curis√©s
- **Solution** : Cr√©er des interfaces strictes pour Request, User, DTO
- **Impact** : ~400+ warnings √©limin√©s

**2. @typescript-eslint/no-unsafe-member-access (PRIORIT√â MAX)**
- **Probl√®me** : Acc√®s aux propri√©t√©s d'objets `any`
- **Solution** : Type guards et interfaces typ√©es
- **Impact** : ~300+ warnings √©limin√©s

**3. @typescript-eslint/no-unsafe-argument (PRIORIT√â MAX)**
- **Probl√®me** : Passage d'arguments `any` √† des fonctions typ√©es
- **Solution** : Validation et casting explicite avec type guards
- **Impact** : ~200+ warnings √©limin√©s

#### **PHASE 2 - √âLEV√âE (1 jour) : Code Quality**

**4. @typescript-eslint/require-await**
- **Probl√®me** : M√©thodes marqu√©es `async` sans utilisation d'`await`
- **Solution** : Enlever `async` et utiliser `Promise.resolve()` OU ajouter de vrais appels `await`
- **Impact** : 8 warnings √©limin√©s

**5. @typescript-eslint/no-unused-vars**
- **Probl√®me** : Variables, imports ou param√®tres d√©clar√©s mais jamais utilis√©s
- **Solution** : Supprimer ou pr√©fixer avec `_` (ex: `_context`, `_error`)
- **Impact** : 4 warnings √©limin√©s

**6. @typescript-eslint/unbound-method**
- **Probl√®me** : R√©f√©rencer des m√©thodes sans lier `this`
- **Solution** : Utiliser des arrow functions ou lier explicitement `this`
- **Impact** : 2 warnings √©limin√©s

#### **PHASE 3 - NORMALE (1 jour) : Cleanup Final**

**7. @typescript-eslint/no-unsafe-return**
- **Probl√®me** : Retour de valeurs `any` depuis des fonctions
- **Solution** : Typage explicite des valeurs de retour
- **Impact** : ~100+ warnings √©limin√©s

**8. @typescript-eslint/no-unsafe-call**
- **Probl√®me** : Appel de fonctions `any`
- **Solution** : Validation des types avant appel
- **Impact** : ~50+ warnings √©limin√©s

#### **üîß TEMPLATES DE CORRECTION OBLIGATOIRES**

```typescript
// ‚úÖ TEMPLATE - Interface Request typ√©e
export interface AuthenticatedRequest extends FastifyRequest {
  user: AuthenticatedUser;
}

// ‚úÖ TEMPLATE - Type guard pour validation
function isValidUser(data: unknown): data is AuthenticatedUser {
  return (
    typeof data === 'object' &&
    data !== null &&
    'id' in data &&
    'email' in data &&
    typeof (data as { id: unknown }).id === 'string' &&
    typeof (data as { email: unknown }).email === 'string'
  );
}

// ‚úÖ TEMPLATE - Controller typ√© correct
@Controller('users')
export class UserController {
  @Get('profile')
  async getProfile(@GetUser() user: AuthenticatedUser): Promise<UserDto> {
    // user est maintenant compl√®tement typ√©
    const userId: string = user.id; // Type-safe
    return this.userService.getProfile(userId);
  }
}

// ‚úÖ TEMPLATE - Transformer DTO typ√©
@Transform(({ value }: { value: unknown }) => {
  if (typeof value !== 'string') {
    throw new ValidationError('Value must be a string');
  }
  return value.trim();
})
readonly name!: string;

// ‚úÖ TEMPLATE - M√©thode async correcte
async delete(id: string): Promise<void> {
  await this.businessService.delete(id); // Avec await
}

// OU
delete(id: string): Promise<void> {
  return this.businessService.delete(id); // Sans async
}

// ‚úÖ TEMPLATE - Variables inutilis√©es
async method(@GetUser() _user: User, @Param('id') _id: string) {
  // Pr√©fixe _ indique explicitement non utilis√©
  return { success: true };
}
```

#### **üìä M√âTRIQUES DE SUCC√àS ATTENDUES**

- **Avant correction** : 1437 warnings
- **Apr√®s Phase 1** : ~500 warnings (-900 warnings)
- **Apr√®s Phase 2** : ~50 warnings (-450 warnings)
- **Apr√®s Phase 3** : 0 warnings (-50 warnings)
- **OBJECTIF** : üéØ **Z√âRO WARNING ESLINT**

#### **üö® R√àGLES D'URGENCE**

1. **JAMAIS commiter** avec plus de 100 warnings ESLint
2. **PRIORIT√â ABSOLUE** aux violations `no-unsafe-*`
3. **Validation obligatoire** : `npm run lint` avant chaque commit
4. **Type safety** : Pr√©f√©rer `unknown` √† `any` TOUJOURS
5. **Interfaces strictes** : Cr√©er des types pour chaque structure de donn√©es

### üìã **Checklist de V√©rification ESLint**

Avant de commiter, TOUJOURS v√©rifier :

- [ ] **Promise.all** : Toutes les valeurs sont des Promises
- [ ] **Regex** : √âchappements minimaux requis uniquement
- [ ] **Async/await** : M√©thodes async utilisent vraiment await
- [ ] **Variables** : Tous les imports/variables sont utilis√©s
- [ ] **Tests** : Mocks correctement typ√©s avec `jest.Mocked<T>`

### üîß **Commandes de Correction**

```bash
# V√©rifier les erreurs ESLint
npm run lint

# Corriger automatiquement ce qui peut l'√™tre
npm run lint -- --fix

# Compiler pour v√©rifier les erreurs TypeScript
npm run build

# Lancer tous les tests
npm test
```

## üö® **CRITIQUE : COUCHES DOMAIN & APPLICATION LIBRES DE FRAMEWORKS**

### üéØ **R√àGLE ABSOLUE : Z√âRO D√©pendance Framework dans la Logique M√©tier**

**Les couches Domain et Application DOIVENT rester compl√®tement libres de toute d√©pendance de framework. C'est un principe fondamental de la Clean Architecture qui garantit :**

- **Ind√©pendance des Frameworks** : Les r√®gles m√©tier ne sont pas coupl√©es √† un framework sp√©cifique
- **Testabilit√©** : La logique m√©tier pure peut √™tre test√©e en isolation
- **Portabilit√©** : La logique centrale peut √™tre d√©plac√©e entre diff√©rents frameworks
- **Maintenabilit√©** : Les changements de frameworks n'affectent pas les r√®gles m√©tier

## üîç **STANDARDISATION API - RECHERCHE & FILTRAGE PAGIN√âS OBLIGATOIRES**

### üéØ **R√àGLE CRITIQUE : TOUTES LES RESSOURCES DOIVENT AVOIR UNE API DE RECHERCHE COH√âRENTE**

**Chaque ressource (User, BusinessSector, Business, etc.) DOIT respecter le m√™me pattern de recherche et filtrage pagin√©s pour garantir une exp√©rience d√©veloppeur coh√©rente.**

#### **üìã Pattern Obligatoire : POST /api/v1/{resource}/list**

```typescript
// ‚úÖ CORRECT - Pattern standardis√© pour TOUTES les ressources
@Post('list')
@ApiOperation({
  summary: 'List {ResourceName}s with advanced search and pagination',
  description: 'Provides comprehensive search, filtering, and pagination for {ResourceName}s'
})
@ApiResponse({ type: List{ResourceName}ResponseDto })
@UseGuards(JwtAuthGuard)
async list(
  @Body() dto: List{ResourceName}sDto,
  @GetUser() user: User,
): Promise<List{ResourceName}ResponseDto> {
  // Impl√©mentation avec use case
}
```

#### **üîß Structure DTO Standardis√©e**

```typescript
// ‚úÖ OBLIGATOIRE - Chaque ressource doit avoir cette structure de base
export class List{ResourceName}sDto {
  @ApiPropertyOptional({ minimum: 1, default: 1 })
  @IsOptional()
  @IsInt()
  @Min(1)
  readonly page?: number = 1;

  @ApiPropertyOptional({ minimum: 1, maximum: 100, default: 10 })
  @IsOptional()
  @IsInt()
  @Min(1)
  @Max(100)
  readonly limit?: number = 10;

  @ApiPropertyOptional({ enum: ['{field1}', '{field2}', 'createdAt'], default: 'createdAt' })
  @IsOptional()
  @IsIn(['{field1}', '{field2}', 'createdAt'])
  readonly sortBy?: string = 'createdAt';

  @ApiPropertyOptional({ enum: ['asc', 'desc'], default: 'desc' })
  @IsOptional()
  @IsIn(['asc', 'desc'])
  readonly sortOrder?: 'asc' | 'desc' = 'desc';

  @ApiPropertyOptional({ description: 'Search term for text fields' })
  @IsOptional()
  @IsString()
  @Length(1, 100)
  readonly search?: string;

  // ‚úÖ Filtres sp√©cifiques √† la ressource
  @ApiPropertyOptional({ description: 'Filter by active status' })
  @IsOptional()
  @IsBoolean()
  readonly isActive?: boolean;

  // Autres filtres sp√©cifiques...
}
```

#### **üìä Response DTO Standardis√©e**

```typescript
// ‚úÖ OBLIGATOIRE - M√©tadonn√©es de pagination coh√©rentes
export class List{ResourceName}ResponseDto {
  @ApiProperty({ type: [{ResourceName}Dto] })
  readonly data: {ResourceName}Dto[];

  @ApiProperty({
    description: 'Pagination metadata',
    example: {
      currentPage: 1,
      totalPages: 5,
      totalItems: 47,
      itemsPerPage: 10,
      hasNextPage: true,
      hasPrevPage: false
    }
  })
  readonly meta: {
    readonly currentPage: number;
    readonly totalPages: number;
    readonly totalItems: number;
    readonly itemsPerPage: number;
    readonly hasNextPage: boolean;
    readonly hasPrevPage: boolean;
  };
}
```

#### **üéØ Use Case Pattern Standardis√©**

```typescript
// ‚úÖ OBLIGATOIRE - Chaque ressource doit avoir un use case de liste
export interface List{ResourceName}sRequest {
  readonly requestingUserId: string;
  readonly pagination: {
    readonly page: number;
    readonly limit: number;
  };
  readonly sorting: {
    readonly sortBy: string;
    readonly sortOrder: 'asc' | 'desc';
  };
  readonly filters: {
    readonly search?: string;
    readonly isActive?: boolean;
    // Filtres sp√©cifiques...
  };
}

export interface List{ResourceName}sResponse {
  readonly data: {ResourceName}[];
  readonly meta: {
    readonly currentPage: number;
    readonly totalPages: number;
    readonly totalItems: number;
    readonly itemsPerPage: number;
    readonly hasNextPage: boolean;
    readonly hasPrevPage: boolean;
  };
}

export class List{ResourceName}sUseCase {
  async execute(request: List{ResourceName}sRequest): Promise<List{ResourceName}sResponse> {
    // 1. Validation des permissions
    // 2. Application des filtres
    // 3. Pagination
    // 4. Tri
    // 5. Mapping vers response
  }
}
```

#### **üìã Checklist Obligatoire pour Chaque Ressource**

- [ ] **Endpoint POST /api/v1/{resource}/list** impl√©ment√©
- [ ] **DTO de requ√™te** avec pagination, tri, recherche, filtres
- [ ] **DTO de r√©ponse** avec metadata pagination coh√©rente
- [ ] **Use Case d√©di√©** pour la logique de recherche
- [ ] **Repository method findAll()** avec support filtres avanc√©s
- [ ] **Mapper** pour conversion DTO ‚Üî Domain ‚Üî Response
- [ ] **Tests unitaires** complets pour use case et controller
- [ ] **Documentation Swagger** d√©taill√©e avec exemples
- [ ] **Validation des permissions** bas√©e sur les r√¥les utilisateur
- [ ] **Gestion d'erreurs** avec messages i18n appropri√©s

#### **üö´ INTERDICTIONS**

- ‚ùå **JAMAIS** d'endpoint GET simple sans filtrage avanc√©
- ‚ùå **JAMAIS** de pagination sans m√©tadonn√©es compl√®tes
- ‚ùå **JAMAIS** de recherche sans validation de permissions
- ‚ùå **JAMAIS** de tri sans validation des champs autoris√©s
- ‚ùå **JAMAIS** de limite de pagination > 100 √©l√©ments

#### **‚úÖ Ressources D√©j√† Conformes**

- **Users** : ‚úÖ POST /api/v1/users/list avec recherche, filtrage, pagination
- **BusinessSectors** : üîÑ √Ä mettre √† jour selon ce standard

#### **üìù TODO : Mise √† Jour des Ressources Existantes**

1. **BusinessSectors** : Remplacer l'endpoint simple par le pattern standardis√©
2. **Businesses** : Impl√©menter le pattern d√®s la cr√©ation
3. **Services** : Impl√©menter le pattern d√®s la cr√©ation
4. **Appointments** : Impl√©menter le pattern d√®s la cr√©ation

**Cette standardisation garantit une API coh√©rente, performante et facilement utilisable par les d√©veloppeurs frontend !**

### üõ£Ô∏è **CONVENTIONS D'ENDPOINTS REST STANDARDIS√âES**

#### **üìã Pattern Obligatoire pour TOUTES les Ressources**

```typescript
// ‚úÖ STRUCTURE ENDPOINT STANDARDIS√âE
@Controller('api/v1/{resources}') // Toujours au pluriel
export class {Resource}Controller {

  // üîç RECHERCHE & LISTE (POST pour filtres complexes)
  @Post('list') // ‚úÖ OBLIGATOIRE pour toutes les ressources
  async list(@Body() dto: List{Resource}sDto): Promise<List{Resource}ResponseDto>

  // üìÑ R√âCUP√âRATION PAR ID
  @Get(':id') // ‚úÖ Standard REST
  async findById(@Param('id') id: string): Promise<{Resource}Dto>

  // ‚ûï CR√âATION
  @Post() // ‚úÖ Standard REST
  async create(@Body() dto: Create{Resource}Dto): Promise<Create{Resource}ResponseDto>

  // ‚úèÔ∏è MISE √Ä JOUR
  @Put(':id') // ‚úÖ Standard REST
  async update(@Param('id') id: string, @Body() dto: Update{Resource}Dto): Promise<Update{Resource}ResponseDto>

  // üóëÔ∏è SUPPRESSION
  @Delete(':id') // ‚úÖ Standard REST
  async delete(@Param('id') id: string): Promise<Delete{Resource}ResponseDto>

  // üìä STATISTIQUES/M√âTRIQUES (optionnel)
  @Get('stats')
  async getStats(): Promise<{Resource}StatsDto>
}
```

#### **üéØ Exemples Concrets d'URLs**

```bash
# ‚úÖ CORRECT - Endpoints standardis√©s
POST   /api/v1/users/list          # Recherche utilisateurs pagin√©e
GET    /api/v1/users/123           # R√©cup√©rer utilisateur par ID
POST   /api/v1/users               # Cr√©er utilisateur
PUT    /api/v1/users/123           # Mettre √† jour utilisateur
DELETE /api/v1/users/123           # Supprimer utilisateur
GET    /api/v1/users/stats         # Statistiques utilisateurs

POST   /api/v1/business-sectors/list    # Recherche secteurs pagin√©e
GET    /api/v1/business-sectors/456     # R√©cup√©rer secteur par ID
POST   /api/v1/business-sectors         # Cr√©er secteur
PUT    /api/v1/business-sectors/456     # Mettre √† jour secteur
DELETE /api/v1/business-sectors/456     # Supprimer secteur

POST   /api/v1/businesses/list          # Recherche entreprises pagin√©e
POST   /api/v1/appointments/list        # Recherche rendez-vous pagin√©e
POST   /api/v1/services/list            # Recherche services pagin√©e
```

#### **‚ùå ANTI-PATTERNS √Ä √âVITER**

```bash
# ‚ùå INTERDIT - Endpoints non standardis√©s
GET    /api/v1/users/all           # Pas de filtrage avanc√©
GET    /api/v1/users/search        # Limit√©, utiliser POST /list
POST   /api/v1/users/filter        # Utiliser POST /list
GET    /api/v1/users/paginated     # Utiliser POST /list
POST   /api/v1/users/find          # Utiliser POST /list

# ‚ùå INTERDIT - URLs mal form√©es
GET    /api/v1/user/123            # Singulier interdit
GET    /api/v1/Users/123           # Casse incorrecte
GET    /api/v1/businessSector/123  # camelCase interdit, utiliser kebab-case
```

#### **üìù R√®gles de Nommage**

1. **Ressources** : Toujours au **pluriel** et en **kebab-case**
   - ‚úÖ `/users`, `/business-sectors`, `/appointments`
   - ‚ùå `/user`, `/businessSectors`, `/Users`

2. **Actions** : Verbes HTTP standard + suffixes conventionnels
   - ‚úÖ `POST /list` pour recherche avanc√©e
   - ‚úÖ `GET /stats` pour statistiques
   - ‚ùå `GET /getAll`, `POST /search`

3. **Param√®tres** : ID en param√®tre de route, filtres complexes en body
   - ‚úÖ `GET /users/123`, `POST /users/list`
   - ‚ùå `GET /users?id=123`

**Cette standardisation assure une API REST coh√©rente et pr√©visible pour tous les d√©veloppeurs !**

### üö® **GESTION D'ERREURS API STANDARDIS√âE**

#### **üìã Format de R√©ponse d'Erreur Obligatoire**

```typescript
// ‚úÖ OBLIGATOIRE - Format d'erreur standardis√© pour toutes les ressources
export interface ApiErrorResponse {
  readonly success: false;
  readonly error: {
    readonly code: string;           // Code d'erreur technique
    readonly message: string;        // Message utilisateur (i18n)
    readonly details?: string;       // D√©tails techniques (dev only)
    readonly field?: string;         // Champ en erreur (validation)
    readonly timestamp: string;      // ISO timestamp
    readonly path: string;           // Endpoint appel√©
    readonly correlationId: string;  // ID pour tracing
  };
}

// ‚úÖ OBLIGATOIRE - Format de r√©ponse succ√®s standardis√©
export interface ApiSuccessResponse<T> {
  readonly success: true;
  readonly data: T;
  readonly meta?: {
    readonly timestamp: string;
    readonly correlationId: string;
  };
}
```

#### **üéØ Codes d'Erreur Standardis√©s par Ressource**

```typescript
// ‚úÖ OBLIGATOIRE - Chaque ressource doit d√©finir ses codes d'erreur
export enum {Resource}ErrorCodes {
  // Erreurs g√©n√©riques (4xx)
  NOT_FOUND = '{RESOURCE}_NOT_FOUND',
  INVALID_DATA = '{RESOURCE}_INVALID_DATA',
  DUPLICATE_ENTRY = '{RESOURCE}_DUPLICATE_ENTRY',
  PERMISSION_DENIED = '{RESOURCE}_PERMISSION_DENIED',

  // Erreurs m√©tier sp√©cifiques
  CANNOT_DELETE_REFERENCED = '{RESOURCE}_CANNOT_DELETE_REFERENCED',
  STATUS_TRANSITION_INVALID = '{RESOURCE}_STATUS_TRANSITION_INVALID',

  // Erreurs syst√®me (5xx)
  REPOSITORY_ERROR = '{RESOURCE}_REPOSITORY_ERROR',
  EXTERNAL_SERVICE_ERROR = '{RESOURCE}_EXTERNAL_SERVICE_ERROR',
}

// Exemple concret pour BusinessSector
export enum BusinessSectorErrorCodes {
  NOT_FOUND = 'BUSINESS_SECTOR_NOT_FOUND',
  INVALID_DATA = 'BUSINESS_SECTOR_INVALID_DATA',
  DUPLICATE_CODE = 'BUSINESS_SECTOR_DUPLICATE_CODE',
  PERMISSION_DENIED = 'BUSINESS_SECTOR_PERMISSION_DENIED',
  CANNOT_DELETE_REFERENCED = 'BUSINESS_SECTOR_CANNOT_DELETE_REFERENCED',
  REPOSITORY_ERROR = 'BUSINESS_SECTOR_REPOSITORY_ERROR',
}
```

#### **üìä Codes de Statut HTTP Standardis√©s**

```typescript
// ‚úÖ OBLIGATOIRE - Mapping coh√©rent des erreurs m√©tier vers HTTP
export const ERROR_HTTP_STATUS_MAP = {
  // 400 - Bad Request
  INVALID_DATA: 400,
  VALIDATION_ERROR: 400,
  BUSINESS_RULE_VIOLATION: 400,

  // 401 - Unauthorized
  AUTHENTICATION_REQUIRED: 401,
  INVALID_CREDENTIALS: 401,
  TOKEN_EXPIRED: 401,

  // 403 - Forbidden
  PERMISSION_DENIED: 403,
  INSUFFICIENT_PERMISSIONS: 403,

  // 404 - Not Found
  NOT_FOUND: 404,
  RESOURCE_NOT_FOUND: 404,

  // 409 - Conflict
  DUPLICATE_ENTRY: 409,
  RESOURCE_ALREADY_EXISTS: 409,
  CONCURRENT_MODIFICATION: 409,

  // 422 - Unprocessable Entity
  CANNOT_DELETE_REFERENCED: 422,
  STATUS_TRANSITION_INVALID: 422,

  // 500 - Internal Server Error
  REPOSITORY_ERROR: 500,
  EXTERNAL_SERVICE_ERROR: 500,
  UNKNOWN_ERROR: 500,
} as const;
```

#### **üîß Exception Filter Global**

```typescript
// ‚úÖ OBLIGATOIRE - Gestionnaire d'erreurs global pour coh√©rence
@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost): void {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    const errorResponse: ApiErrorResponse = {
      success: false,
      error: {
        code: this.getErrorCode(exception),
        message: this.getI18nMessage(exception),
        details: this.getErrorDetails(exception),
        field: this.getFieldName(exception),
        timestamp: new Date().toISOString(),
        path: request.url,
        correlationId: this.getCorrelationId(request),
      },
    };

    const statusCode = this.getHttpStatus(exception);
    response.status(statusCode).json(errorResponse);
  }
}
```

#### **üìù Messages d'Erreur Internationalis√©s**

```typescript
// ‚úÖ OBLIGATOIRE - Messages i18n pour toutes les erreurs
// src/shared/i18n/en/errors.json
{
  "BUSINESS_SECTOR_NOT_FOUND": "Business sector not found",
  "BUSINESS_SECTOR_DUPLICATE_CODE": "A business sector with this code already exists",
  "BUSINESS_SECTOR_PERMISSION_DENIED": "You don't have permission to manage business sectors",
  "BUSINESS_SECTOR_CANNOT_DELETE_REFERENCED": "Cannot delete business sector: it is referenced by existing businesses"
}

// src/shared/i18n/fr/errors.json
{
  "BUSINESS_SECTOR_NOT_FOUND": "Secteur d'activit√© introuvable",
  "BUSINESS_SECTOR_DUPLICATE_CODE": "Un secteur d'activit√© avec ce code existe d√©j√†",
  "BUSINESS_SECTOR_PERMISSION_DENIED": "Vous n'avez pas l'autorisation de g√©rer les secteurs d'activit√©",
  "BUSINESS_SECTOR_CANNOT_DELETE_REFERENCED": "Impossible de supprimer le secteur : il est r√©f√©renc√© par des entreprises existantes"
}
```

#### **üö´ INTERDICTIONS - Gestion d'Erreurs**

- ‚ùå **JAMAIS** renvoyer des stack traces en production
- ‚ùå **JAMAIS** exposer des d√©tails internes de la base de donn√©es
- ‚ùå **JAMAIS** utiliser des messages d'erreur g√©n√©riques ("Internal Error")
- ‚ùå **JAMAIS** oublier la corr√©lation ID pour le debugging
- ‚ùå **JAMAIS** renvoyer des codes HTTP incoh√©rents

**Cette standardisation garantit une gestion d'erreurs coh√©rente et debuggable sur toute l'API !**

## üìö **DOCUMENTATION SWAGGER - WORKFLOW COMPLET OBLIGATOIRE**

### üéØ **R√àGLE CRITIQUE : API DOCUMENTATION COMPL√àTE ET FRONTEND-FRIENDLY**

**Apr√®s avoir cr√©√© les Controllers et DTOs, TOUJOURS cr√©er une documentation Swagger compl√®te pour garantir une API utilisable, coh√©rente et facilement int√©grable par les √©quipes frontend.**

#### **üìã WORKFLOW DOCUMENTATION OBLIGATOIRE APR√àS PR√âSENTATION**

#### **1Ô∏è‚É£ R√àGLE ROUTE PREFIXING - √âVITER DOUBLE /v1/v1/**

```typescript
// ‚úÖ CORRECT - main.ts avec globalPrefix
app.setGlobalPrefix('api/v1');

// ‚úÖ CORRECT - Controllers SANS pr√©fixe redondant
@Controller('services')  // ‚Üí /api/v1/services
@Controller('staff')     // ‚Üí /api/v1/staff
@Controller('appointments') // ‚Üí /api/v1/appointments

// ‚ùå INTERDIT - Double pr√©fixage
@Controller('api/v1/services') // ‚Üí /api/v1/api/v1/services (ERREUR!)
```

#### **2Ô∏è‚É£ TAGS SWAGGER OBLIGATOIRES PAR RESSOURCE**

```typescript
// ‚úÖ OBLIGATOIRE - Tags avec ic√¥nes pour clart√©
@ApiTags('üíº Services')           // Services m√©tier
@ApiTags('üë®‚Äçüíº Staff Management')    // Gestion personnel
@ApiTags('üìÖ Appointments')       // Rendez-vous
@ApiTags('üè¢ Business Management') // Gestion entreprises
@ApiTags('üë• User Management')    // Gestion utilisateurs
@ApiTags('‚ù§Ô∏è Health Checks')      // Sant√© syst√®me
```

#### **3Ô∏è‚É£ DOCUMENTATION SWAGGER ENRICHIE OBLIGATOIRE**

```typescript
// ‚úÖ TEMPLATE OBLIGATOIRE - Documentation compl√®te avec exemples
@ApiOperation({
  summary: 'üîç Search {Resource}s with Advanced Filters',
  description: `
    **Recherche avanc√©e pagin√©e** des {resource}s avec syst√®me de filtrage complet.

    ## üéØ Fonctionnalit√©s

    ### üìä **Filtres disponibles**
    - **Recherche textuelle** : Nom, description, tags
    - **Filtres m√©tier** : Statut, cat√©gorie, prix
    - **Tri multi-crit√®res** : Tous champs avec asc/desc
    - **Pagination** : Page/limit avec m√©tadonn√©es compl√®tes

    ### üí∞ **Exemple pricing complexe**
    \`\`\`json
    {
      "pricingConfig": {
        "type": "VARIABLE",
        "basePrice": { "amount": 80.00, "currency": "EUR" },
        "variablePricing": {
          "factors": [
            {
              "name": "Dur√©e",
              "options": [
                { "label": "30 min", "priceModifier": 0 },
                { "label": "60 min", "priceModifier": 40 }
              ]
            }
          ]
        }
      }
    }
    \`\`\`

    ### üìã **R√®gles m√©tier**
    - ‚úÖ **Permissions** : Scoped selon r√¥le utilisateur
    - ‚úÖ **Validation** : Tous param√®tres valid√©s c√¥t√© serveur
    - ‚úÖ **Performance** : Pagination obligatoire, cache Redis

    ### üîê **S√©curit√©**
    - **JWT** : Token Bearer obligatoire
    - **RBAC** : Permissions granulaires par ressource
    - **Rate limiting** : 100 req/min par utilisateur

    ## üéØ **Guide d'int√©gration Frontend**

    ### React/Vue.js Example
    \`\`\`typescript
    const searchServices = async (filters: ServiceFilters) => {
      const response = await api.post('/api/v1/services/list', {
        ...filters,
        page: 1,
        limit: 20
      });

      return {
        services: response.data.data,
        pagination: response.data.meta
      };
    };
    \`\`\`
  `,
})
```

#### **4Ô∏è‚É£ CHECKLIST OBLIGATOIRE APR√àS CHAQUE PR√âSENTATION**

- [ ] **Routes** : Aucun double pr√©fixage /v1/v1/
- [ ] **Tags** : @ApiTags avec ic√¥nes sur tous les controllers
- [ ] **Operations** : @ApiOperation avec description compl√®te et exemples
- [ ] **Responses** : Tous codes HTTP document√©s avec exemples JSON
- [ ] **DTOs** : Validation et Swagger schemas complets
- [ ] **Config** : Swagger config central avec guide int√©gration
- [ ] **Documentation** : Fichier markdown complet par fonctionnalit√©
- [ ] **Frontend** : Exemples TypeScript/React/Vue.js
- [ ] **Tests** : Validation Swagger UI accessible et compl√®te
- [ ] **Push** : Code test√© et documentation √† jour

#### **5Ô∏è‚É£ CONFIGURATION SWAGGER CENTRALE ENRICHIE**

```typescript
// ‚úÖ OBLIGATOIRE - Configuration Swagger avec guide int√©gration complet
const config = new DocumentBuilder()
  .setTitle('üéØ Appointment System API')
  .setDescription(`
    ## üöÄ **API Compl√®te pour Syst√®me de Rendez-vous**

    ### üìã **Fonctionnalit√©s Principales**

    - **üè¢ Gestion d'entreprises** : Secteurs, profils, configuration
    - **üë®‚Äçüíº Personnel** : Staff, disponibilit√©s, comp√©tences
    - **üíº Services** : Pricing flexible, packages, pr√©requis
    - **üìÖ Rendez-vous** : R√©servation, notifications, historique
    - **üë• Utilisateurs** : Authentification, r√¥les, permissions

    ### üîê **Authentification**

    Toutes les APIs n√©cessitent un **JWT Bearer Token** :

    \`\`\`bash
    curl -H "Authorization: Bearer YOUR_JWT_TOKEN" \\
         -X POST http://localhost:3000/api/v1/services/list
    \`\`\`

    ### üìä **Standards de R√©ponse**

    #### ‚úÖ **Succ√®s**
    \`\`\`json
    {
      "success": true,
      "data": { /* Donn√©es m√©tier */ },
      "meta": { /* M√©tadonn√©es pagination */ }
    }
    \`\`\`

    #### ‚ùå **Erreur**
    \`\`\`json
    {
      "success": false,
      "error": {
        "code": "BUSINESS_ERROR_CODE",
        "message": "Message utilisateur localis√©",
        "field": "champEnErreur"
      }
    }
    \`\`\`

    ### üéØ **Guides d'Int√©gration**

    - **React/Vue.js** : Exemples TypeScript fournis
    - **Pagination** : Syst√®me uniforme avec m√©tadonn√©es
    - **Filtrage** : POST /list pour requ√™tes complexes
    - **Pricing** : Syst√®me flexible pour tous cas d'usage

    ### üìû **Support**

    - **Documentation** : Exemples complets dans chaque endpoint
    - **Types TypeScript** : Interfaces g√©n√©r√©es automatiquement
    - **Postman Collection** : Import direct depuis Swagger JSON
  `)
  .setVersion('2.0')
  .addBearerAuth()
  .addTag('üíº Services', 'Gestion des services et tarification flexible')
  .addTag('üë®‚Äçüíº Staff Management', 'Personnel et disponibilit√©s')
  .addTag('üìÖ Appointments', 'Syst√®me de rendez-vous complet')
  .addTag('üè¢ Business Management', 'Entreprises et secteurs d\'activit√©')
  .addTag('üë• User Management', 'Utilisateurs et authentification')
  .addTag('‚ù§Ô∏è Health Checks', 'Monitoring et sant√© syst√®me');
```

#### **üö´ INTERDICTIONS - Documentation Swagger**

- ‚ùå **JAMAIS** de controller sans @ApiTags
- ‚ùå **JAMAIS** d'endpoint sans @ApiOperation d√©taill√©e
- ‚ùå **JAMAIS** de double pr√©fixage de routes
- ‚ùå **JAMAIS** d'exemples JSON incomplets ou faux
- ‚ùå **JAMAIS** oublier les guides d'int√©gration frontend

**Cette r√®gle garantit des APIs professionnelles, document√©es et facilement int√©grables !**

### üß™ **TESTS D'INT√âGRATION API STANDARDIS√âS**

#### **üìã Pattern de Tests Obligatoire pour Chaque Ressource**

```typescript
// ‚úÖ OBLIGATOIRE - Structure de tests d'int√©gration pour chaque ressource
describe('{Resource}Controller (e2e)', () => {
  let app: INestApplication;
  let authToken: string;

  beforeAll(async () => {
    // Setup application et authentification
  });

  describe('POST /api/v1/{resources}/list', () => {
    it('should return paginated list with default parameters', async () => {
      const response = await request(app.getHttpServer())
        .post('/api/v1/{resources}/list')
        .set('Authorization', `Bearer ${authToken}`)
        .send({})
        .expect(200);

      expect(response.body).toMatchObject({
        success: true,
        data: expect.any(Array),
        meta: {
          currentPage: 1,
          totalPages: expect.any(Number),
          totalItems: expect.any(Number),
          itemsPerPage: 10,
          hasNextPage: expect.any(Boolean),
          hasPrevPage: false,
        },
      });
    });

    it('should apply search filters correctly', async () => {
      const response = await request(app.getHttpServer())
        .post('/api/v1/{resources}/list')
        .set('Authorization', `Bearer ${authToken}`)
        .send({
          search: 'test search term',
          isActive: true,
          page: 1,
          limit: 5,
        })
        .expect(200);

      expect(response.body.meta.itemsPerPage).toBe(5);
      // V√©rifier que les r√©sultats correspondent au filtre
    });

    it('should enforce pagination limits', async () => {
      await request(app.getHttpServer())
        .post('/api/v1/{resources}/list')
        .set('Authorization', `Bearer ${authToken}`)
        .send({ limit: 150 }) // > 100
        .expect(400);
    });

    it('should require authentication', async () => {
      await request(app.getHttpServer())
        .post('/api/v1/{resources}/list')
        .send({})
        .expect(401);
    });
  });

  describe('GET /api/v1/{resources}/:id', () => {
    it('should return resource by ID', async () => {
      const response = await request(app.getHttpServer())
        .get('/api/v1/{resources}/valid-uuid')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body).toMatchObject({
        success: true,
        data: {
          id: 'valid-uuid',
          // Autres propri√©t√©s attendues
        },
      });
    });

    it('should return 404 for non-existent resource', async () => {
      const response = await request(app.getHttpServer())
        .get('/api/v1/{resources}/non-existent-uuid')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(404);

      expect(response.body).toMatchObject({
        success: false,
        error: {
          code: '{RESOURCE}_NOT_FOUND',
          message: expect.any(String),
        },
      });
    });
  });

  describe('POST /api/v1/{resources}', () => {
    it('should create resource with valid data', async () => {
      const createDto = {
        // Donn√©es valides pour cr√©ation
      };

      const response = await request(app.getHttpServer())
        .post('/api/v1/{resources}')
        .set('Authorization', `Bearer ${authToken}`)
        .send(createDto)
        .expect(201);

      expect(response.body).toMatchObject({
        success: true,
        data: {
          id: expect.any(String),
          ...createDto,
          createdAt: expect.any(String),
          updatedAt: expect.any(String),
        },
      });
    });

    it('should validate required fields', async () => {
      const response = await request(app.getHttpServer())
        .post('/api/v1/{resources}')
        .set('Authorization', `Bearer ${authToken}`)
        .send({}) // Donn√©es manquantes
        .expect(400);

      expect(response.body.error.code).toBe('{RESOURCE}_INVALID_DATA');
    });
  });

  describe('PUT /api/v1/{resources}/:id', () => {
    it('should update resource with valid data', async () => {
      const updateDto = {
        // Donn√©es de mise √† jour
      };

      const response = await request(app.getHttpServer())
        .put('/api/v1/{resources}/valid-uuid')
        .set('Authorization', `Bearer ${authToken}`)
        .send(updateDto)
        .expect(200);

      expect(response.body.data).toMatchObject(updateDto);
    });
  });

  describe('DELETE /api/v1/{resources}/:id', () => {
    it('should delete resource successfully', async () => {
      await request(app.getHttpServer())
        .delete('/api/v1/{resources}/valid-uuid')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      // V√©rifier que la ressource est supprim√©e
      await request(app.getHttpServer())
        .get('/api/v1/{resources}/valid-uuid')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(404);
    });
  });
});
```

#### **üéØ Donn√©es de Test Standardis√©es**

```typescript
// ‚úÖ OBLIGATOIRE - Factory de donn√©es de test pour chaque ressource
export class {Resource}TestDataFactory {
  static createValid{Resource}Data(): Create{Resource}Dto {
    return {
      // Donn√©es valides minimales
    };
  }

  static createInvalid{Resource}Data(): Partial<Create{Resource}Dto> {
    return {
      // Donn√©es invalides pour tests de validation
    };
  }

  static createUpdate{Resource}Data(): Update{Resource}Dto {
    return {
      // Donn√©es de mise √† jour
    };
  }

  static createList{Resource}Filters(): List{Resource}sDto {
    return {
      search: 'test',
      isActive: true,
      page: 1,
      limit: 10,
      sortBy: 'createdAt',
      sortOrder: 'desc',
    };
  }
}
```

#### **üìä M√©triques de Couverture Obligatoires**

```typescript
// ‚úÖ OBLIGATOIRE - Checklist de couverture des tests API
const API_TEST_COVERAGE_CHECKLIST = {
  // Endpoints CRUD complets
  'POST /list': ['success', 'pagination', 'filters', 'auth', 'permissions'],
  'GET /:id': ['success', 'not_found', 'auth', 'permissions'],
  'POST /': ['success', 'validation', 'auth', 'permissions', 'duplicates'],
  'PUT /:id': ['success', 'validation', 'not_found', 'auth', 'permissions'],
  'DELETE /:id': ['success', 'not_found', 'auth', 'permissions', 'constraints'],

  // Cas d'erreur obligatoires
  error_handling: ['400', '401', '403', '404', '409', '422', '500'],

  // Validations m√©tier
  business_rules: ['required_fields', 'format_validation', 'constraints'],

  // S√©curit√©
  security: ['authentication', 'authorization', 'input_sanitization'],
} as const;
```

#### **üö´ INTERDICTIONS - Tests API**

- ‚ùå **JAMAIS** tester sans donn√©es de test isol√©es
- ‚ùå **JAMAIS** ignorer les tests de permissions/s√©curit√©
- ‚ùå **JAMAIS** oublier les tests de validation des limites
- ‚ùå **JAMAIS** tester sans cleanup des donn√©es
- ‚ùå **JAMAIS** utiliser des donn√©es de production dans les tests

**Cette standardisation garantit une couverture de tests compl√®te et coh√©rente pour toutes les APIs !**

### ‚ùå **STRICTEMENT INTERDIT dans Domain/Application**

```typescript
// ‚ùå JAMAIS importer des d√©pendances de framework dans Domain/Application
import { Injectable, Inject } from '@nestjs/common';        // INTERDIT
import { Repository } from 'typeorm';                       // INTERDIT
import { Request, Response } from 'express';                // INTERDIT
import { GraphQLResolveInfo } from 'graphql';              // INTERDIT
import { JwtService } from '@nestjs/jwt';                   // INTERDIT
import { ConfigService } from '@nestjs/config';            // INTERDIT

// ‚ùå JAMAIS utiliser des d√©corateurs de framework dans Domain/Application
@Injectable()  // INTERDIT dans Domain/Application
@Entity()      // INTERDIT dans Domain/Application
@Column()      // INTERDIT dans Domain/Application
```

### ‚úÖ **CORRECT : TypeScript Pur dans Domain/Application**

```typescript
// ‚úÖ Couche Domain - Logique m√©tier pure
export class User {
  private constructor(
    private readonly id: string,
    private readonly email: Email,
    private readonly name: string,
  ) {}

  static create(email: Email, name: string): User {
    // Validation m√©tier pure - aucune d√©pendance framework
    if (!name || name.trim().length < 2) {
      throw new DomainError('User name must be at least 2 characters');
    }
    return new User(generateId(), email, name);
  }
}

// ‚úÖ Couche Application - Orchestration des cas d'usage
export class CreateUserUseCase {
  constructor(
    private readonly userRepository: IUserRepository,  // Interface uniquement
    private readonly logger: ILogger,                  // Interface uniquement
    private readonly eventBus: IEventBus,             // Interface uniquement
  ) {}

  async execute(request: CreateUserRequest): Promise<CreateUserResponse> {
    // Logique d'orchestration pure - aucune d√©pendance framework
    const email = Email.create(request.email);
    const user = User.create(email, request.name);

    const savedUser = await this.userRepository.save(user);
    await this.eventBus.publish(new UserCreatedEvent(savedUser));

    return CreateUserResponse.fromUser(savedUser);
  }
}
```

### üèóÔ∏è **Architecture d'Injection de D√©pendances Appropri√©e**

L'injection de d√©pendances sp√©cifique aux frameworks ne doit avoir lieu que dans les couches **Infrastructure** et **Presentation** :

```typescript
// ‚úÖ Couche Infrastructure - Impl√©mentations framework
@Injectable()  // OK ici - Couche Infrastructure
export class TypeOrmUserRepository implements IUserRepository {
  constructor(
    @InjectRepository(UserEntity)  // OK ici - Couche Infrastructure
    private readonly repository: Repository<UserEntity>,
  ) {}
}

// ‚úÖ Couche Presentation - Contr√¥leurs avec int√©gration framework
@Controller('users')  // OK ici - Couche Presentation
export class UserController {
  constructor(
    @Inject(TOKENS.CREATE_USER_USE_CASE)  // OK ici - Couche Presentation
    private readonly createUserUseCase: CreateUserUseCase,
  ) {}
}

// ‚úÖ Couche Infrastructure - Configuration des modules
@Module({  // OK ici - Couche Infrastructure
  providers: [
    {
      provide: TOKENS.CREATE_USER_USE_CASE,
      useFactory: (userRepo, logger, eventBus) =>
        new CreateUserUseCase(userRepo, logger, eventBus),
      inject: [TOKENS.USER_REPOSITORY, TOKENS.LOGGER, TOKENS.EVENT_BUS],
    },
  ],
})
export class ApplicationModule {}
```

### üìã **Matrice de Responsabilit√©s par Couche**

| Couche | Usage Framework | Injection D√©pendances | D√©corateurs | Biblioth√®ques Externes |
|-------|----------------|----------------------|------------|------------------------|
| **Domain** | ‚ùå JAMAIS | ‚ùå JAMAIS | ‚ùå JAMAIS | ‚ùå Seulement si pur (lodash, date-fns) |
| **Application** | ‚ùå JAMAIS | ‚ùå JAMAIS | ‚ùå JAMAIS | ‚ùå Seulement si pur (lodash, date-fns) |
| **Infrastructure** | ‚úÖ OUI | ‚úÖ OUI | ‚úÖ OUI | ‚úÖ OUI |
| **Presentation** | ‚úÖ OUI | ‚úÖ OUI | ‚úÖ OUI | ‚úÖ OUI |

### üö® **D√©tection des Violations**

Pour d√©tecter les violations, v√©rifiez r√©guli√®rement :

```bash
# V√©rifier les imports NestJS dans Domain/Application
grep -r "@nestjs" src/domain/ src/application/

# V√©rifier les d√©corateurs de framework dans Domain/Application
grep -r "@Injectable\|@Entity\|@Column\|@Repository" src/domain/ src/application/

# V√©rifier les imports ORM dans Domain/Application
grep -r "typeorm\|mongoose\|prisma" src/domain/ src/application/
```

**Tout r√©sultat de ces commandes indique une violation de Clean Architecture qui doit √™tre corrig√©e imm√©diatement !**

## üîó **Husky & Application des Commits S√©mantiques**

### üéØ **Hooks de Pr√©-commit avec Husky**

Husky applique automatiquement la qualit√© du code et les standards de commit :

```json
// package.json - Configuration Husky
{
  "scripts": {
    "prepare": "husky install",
    "pre-commit": "lint-staged",
    "commit-msg": "commitlint --edit $1"
  },
  "lint-staged": {
    "*.{ts,js}": [
      "eslint --fix",
      "prettier --write"
    ],
    "*.{json,md}": [
      "prettier --write"
    ]
  }
}
```

### üîß **Configuration des Hooks Husky**

```bash
# .husky/pre-commit
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

echo "üîç Ex√©cution des v√©rifications de pr√©-commit..."

# Ex√©cuter lint-staged pour le formatage et le linting du code
npx lint-staged

# Lancer les tests pour s'assurer que rien n'est cass√©
npm test

echo "‚úÖ V√©rifications de pr√©-commit r√©ussies !"
```

```bash
# .husky/commit-msg
#!/usr/bin/env sh
. "$(dirname -- "$0")/_/husky.sh"

echo "üîç Validation du message de commit..."
npx --no -- commitlint --edit $1
echo "‚úÖ Message de commit valide !"
```

### üìã **Workflow de Commit**

1. **Modifications du Code** : Faire vos changements
2. **Formatage Automatique** : Husky ex√©cute ESLint + Prettier sur les fichiers stag√©s
3. **Validation des Tests** : Tous les tests doivent passer
4. **Validation du Message de Commit** : Doit suivre le format de commit conventionnel
5. **Succ√®s du Commit** : Seulement si toutes les v√©rifications passent

### üö´ **Actions Bloqu√©es**

Husky emp√™chera les commits si :
- Des erreurs ESLint existent
- Les tests √©chouent
- Le message de commit ne suit pas la convention
- Le code n'est pas correctement format√©

Cela garantit **100% de qualit√© du code** et **un historique de commits coh√©rent** !

## üö® **R√àGLE M√âTIER CRITIQUE : PRISE DE RENDEZ-VOUS PUBLIQUE UNIQUEMENT**

### üéØ **NOUVELLE R√àGLE IMPL√âMENT√âE**

**‚ö†Ô∏è R√àGLE BUSINESS CRITIQUE** : Seuls les services avec `allowOnlineBooking: true` peuvent √™tre r√©serv√©s directement par les clients.

#### **üîß Impl√©mentation Technique**

```typescript
// ‚úÖ OBLIGATOIRE - Validation dans tous les use cases de r√©servation
if (!service.isBookable()) {
  this.logger.error('Service does not allow online booking', {
    serviceId,
    allowOnlineBooking: false,
  });
  throw new ServiceNotBookableOnlineError(serviceId);
}
```

#### **üìã Entit√© Service - M√©thodes Critiques**

```typescript
// ‚úÖ M√©thodes √† utiliser pour validation
service.isActive()    // Service doit √™tre actif
service.isBookable()  // Service doit autoriser prise de rendez-vous en ligne
service.canBeBookedBy(clientAge) // Validation des restrictions d'√¢ge
```

#### **üö® Exception Standardis√©e**

```typescript
export class ServiceNotBookableOnlineError extends AppointmentException {
  constructor(serviceId: string) {
    super(
      `Service ${serviceId} does not allow online booking`,
      'SERVICE_NOT_BOOKABLE_ONLINE',
      { serviceId },
    );
  }
}
```

#### **‚úÖ Cahier des Charges Mis √† Jour**

Cette r√®gle est maintenant document√©e dans `CAHIER_DES_CHARGES_V2.md` section **Syst√®me de Rendez-vous**.

## üö® **R√àGLE CRITIQUE : JAMAIS COMMITER AVEC DES ERREURS ESLINT**

### ‚ùå **INTERDICTION ABSOLUE**

**Il est STRICTEMENT INTERDIT de commiter du code avec des erreurs ESLint ou des tests qui √©chouent.**

Cette r√®gle est **NON-N√âGOCIABLE** pour maintenir :
- **Qualit√© du code** constante
- **Stabilit√©** du projet
- **Maintenabilit√©** √† long terme
- **Coh√©rence** de l'√©quipe

### üîß **Workflow de Commit OBLIGATOIRE**

#### **1Ô∏è‚É£ Format + Reorganize Imports**
```bash
# Formatter le code avec Prettier
npm run format

# R√©organiser automatiquement les imports TypeScript
npx tsc --organizeImports src/**/*.ts
# OU utiliser l'action VS Code "Organize Imports" (Shift+Alt+O)
```

#### **2Ô∏è‚É£ Lint avec Correction Automatique**
```bash
# Lancer ESLint avec correction automatique
npm run lint -- --fix

# V√©rifier qu'il n'y a AUCUNE erreur restante
npm run lint
```

#### **3Ô∏è‚É£ V√©rification des Tests**
```bash
# S'assurer que TOUS les tests passent
npm test

# V√©rification sp√©cifique des tests unitaires
npm run test:unit

# Optionnel : V√©rifier la coverage
npm run test:cov
```

#### **4Ô∏è‚É£ Commit S√©mantique**
```bash
# Commit avec message s√©mantique conforme
git add .
git commit -m "üéâ feat(scope): description claire et concise"
```

### ‚ö° **Commandes Rapides Pr√©-Commit**

```bash
# Script complet de pr√©-commit (recommand√©)
npm run format && npm run lint -- --fix && npm test && git add .

# V√©rification finale avant commit
npm run lint && npm test
```

### üéØ **Organiser les Imports TypeScript**

#### **Automatique avec VS Code**
- **Raccourci** : `Shift + Alt + O`
- **Command Palette** : `> TypeScript: Organize Imports`
- **Au sauvegarde** : Configurer `"editor.codeActionsOnSave": {"source.organizeImports": true}`

#### **Via Terminal**
```bash
# Organiser les imports pour tous les fichiers TypeScript
find src -name "*.ts" -exec npx tsc --noEmit --organizeImports {} \;

# Ou utiliser un plugin ESLint
npm run lint -- --fix-type suggestion
```

### üìã **Checklist Pr√©-Commit OBLIGATOIRE**

- [ ] ‚úÖ **Format** : Code format√© avec Prettier
- [ ] ‚úÖ **Imports** : Imports r√©organis√©s automatiquement
- [ ] ‚úÖ **Lint** : Aucune erreur ESLint (0 errors, warnings acceptables)
- [ ] ‚úÖ **Tests** : Tous les tests passent (0 failed)
- [ ] ‚úÖ **Build** : Compilation TypeScript r√©ussie
- [ ] ‚úÖ **Message** : Commit s√©mantique conforme

### üö® **Sanctions pour Non-Respect**

Le non-respect de ces r√®gles entra√Æne :
- **Rejet automatique** du commit par Husky
- **Blocage de la CI/CD**
- **Demande de correction imm√©diate**
- **Review obligatoire** pour violations r√©p√©t√©es

### üí° **Configuration IDE Recommand√©e**

```json
// .vscode/settings.json
{
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.organizeImports": true,
    "source.fixAll.eslint": true
  },
  "eslint.validate": ["typescript"],
  "typescript.preferences.organizeImports": true
}
```

**Cette r√®gle garantit un code de qualit√© professionnelle et une collaboration d'√©quipe fluide !**

## üóÑÔ∏è **R√àGLE CRITIQUE : MIGRATIONS TYPEORM ET SCH√âMAS**

### üéØ **R√àGLE OBLIGATOIRE : R√âCUP√âRATION DU SCH√âMA DEPUIS LES VARIABLES D'ENVIRONNEMENT**

**‚ö†Ô∏è R√àGLE NON-N√âGOCIABLE** : Dans toutes les migrations TypeORM, le nom du sch√©ma DOIT √™tre r√©cup√©r√© depuis les variables d'environnement pour garantir la portabilit√© entre environnements (development, staging, production).

#### **‚úÖ PATTERN OBLIGATOIRE POUR MIGRATIONS TYPEORM**

```typescript
import { MigrationInterface, QueryRunner } from 'typeorm';

export class AddFlexiblePricingToServices{Timestamp} implements MigrationInterface {
  name = 'AddFlexiblePricingToServices{Timestamp}';

  // üéØ OBLIGATOIRE : R√©cup√©rer le sch√©ma depuis l'environnement
  private getSchemaName(): string {
    return process.env.DB_SCHEMA || 'public';
  }

  public async up(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ CORRECT : Utiliser le sch√©ma dynamique
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services"
      ADD COLUMN "pricing_config" jsonb DEFAULT '{"type":"FIXED","visibility":"PUBLIC","basePrice":{"amount":0,"currency":"EUR"},"rules":[]}'::jsonb
    `);

    // ‚úÖ CORRECT : Index avec sch√©ma dynamique
    await queryRunner.query(`
      CREATE INDEX "IDX_services_pricing_type"
      ON "${schema}"."services" USING GIN (("pricing_config"->>'type'))
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ CORRECT : Rollback avec sch√©ma dynamique
    await queryRunner.query(`DROP INDEX IF EXISTS "${schema}"."IDX_services_pricing_type"`);
    await queryRunner.query(`ALTER TABLE "${schema}"."services" DROP COLUMN IF EXISTS "pricing_config"`);
  }
}
```

#### **‚ùå ANTI-PATTERNS STRICTEMENT INTERDITS**

```typescript
// ‚ùå INTERDIT : Sch√©ma hardcod√©
await queryRunner.query(`ALTER TABLE "public"."services" ADD COLUMN...`);

// ‚ùå INTERDIT : Pas de gestion d'environnement
await queryRunner.query(`ALTER TABLE services ADD COLUMN...`); // Pas de sch√©ma du tout

// ‚ùå INTERDIT : Sch√©ma non configurable
const schema = 'public'; // Valeur fixe
```

#### **üîß PATTERNS AVANC√âS OBLIGATOIRES**

```typescript
// ‚úÖ EXCELLENT : Gestion compl√®te avec validation
export class ExampleMigration implements MigrationInterface {
  private getSchemaName(): string {
    const schema = process.env.DB_SCHEMA || 'public';

    // Validation du nom de sch√©ma (s√©curit√©)
    if (!/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(schema)) {
      throw new Error(`Invalid schema name: ${schema}`);
    }

    return schema;
  }

  private async schemaExists(queryRunner: QueryRunner, schemaName: string): Promise<boolean> {
    const result = await queryRunner.query(`
      SELECT EXISTS(
        SELECT 1 FROM information_schema.schemata
        WHERE schema_name = $1
      ) as exists
    `, [schemaName]);

    return result[0]?.exists || false;
  }

  public async up(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // V√©rifier que le sch√©ma existe
    const exists = await this.schemaExists(queryRunner, schema);
    if (!exists) {
      throw new Error(`Schema "${schema}" does not exist`);
    }

    // Migration avec sch√©ma valid√©
    await queryRunner.query(`
      ALTER TABLE "${schema}"."table_name"
      ADD COLUMN "new_column" VARCHAR(255)
    `);
  }
}
```

#### **üìã VARIABLES D'ENVIRONNEMENT REQUISES**

```bash
# .env files obligatoires
DB_SCHEMA=public                    # Development
DB_SCHEMA=appointment_system_dev    # Development avec sch√©ma d√©di√©
DB_SCHEMA=appointment_system_staging # Staging
DB_SCHEMA=appointment_system_prod   # Production
```

#### **üö® D√âTECTION DES VIOLATIONS**

```bash
# V√©rifier les migrations avec sch√©mas hardcod√©s
grep -r '"public"' src/infrastructure/database/sql/postgresql/migrations/
# R√âSULTAT ATTENDU : Aucun r√©sultat (0 ligne)

# V√©rifier l'utilisation des variables d'environnement
grep -r "process.env.DB_SCHEMA" src/infrastructure/database/sql/postgresql/migrations/
# R√âSULTAT ATTENDU : Toutes les migrations utilisent cette variable

# V√©rifier les requ√™tes sans sch√©ma
grep -r "ALTER TABLE [^\"']" src/infrastructure/database/sql/postgresql/migrations/
# R√âSULTAT ATTENDU : Aucune requ√™te sans guillemets et sch√©ma
```

#### **‚úÖ CHECKLIST MIGRATION TYPEORM OBLIGATOIRE**

- [ ] ‚úÖ **M√©thode `getSchemaName()`** pr√©sente dans chaque migration
- [ ] ‚úÖ **Variable `DB_SCHEMA`** utilis√©e dans toutes les requ√™tes
- [ ] ‚úÖ **Validation du nom de sch√©ma** pour la s√©curit√©
- [ ] ‚úÖ **Sch√©mas quoted** dans toutes les requ√™tes SQL (`"${schema}"`)
- [ ] ‚úÖ **M√©thode `up()` et `down()`** utilisent le sch√©ma dynamique
- [ ] ‚úÖ **Index et contraintes** cr√©√©s avec le bon sch√©ma
- [ ] ‚úÖ **Tests de migration** sur diff√©rents sch√©mas
- [ ] ‚úÖ **Documentation** des variables d'environnement requises

#### **üéØ AVANTAGES DE CETTE APPROCHE**

1. **Portabilit√©** : M√™me migration fonctionne sur tous les environnements
2. **S√©curit√©** : Isolation des donn√©es par sch√©ma
3. **Flexibilit√©** : Support de d√©ploiements multi-tenants
4. **Maintenance** : Pas de duplication de code selon l'environnement
5. **CI/CD** : Automatisation compl√®te sans intervention manuelle

### üö® **SANCTIONS POUR NON-RESPECT**

Le non-respect de cette r√®gle entra√Æne :
- **Blocage de la migration** en environnement de production
- **Erreurs de d√©ploiement** et corruption potentielle de donn√©es
- **Review obligatoire** et refactoring imm√©diat
- **Formation suppl√©mentaire** sur les bonnes pratiques PostgreSQL

**Cette r√®gle est CRITIQUE pour la stabilit√© et la s√©curit√© de la base de donn√©es !**
`````

## üö® **ERREURS COURANTES NestJS - INJECTION DE D√âPENDANCES**

### üéØ **ERREUR CRITIQUE : UnknownDependenciesException**

**‚ùå ERREUR FR√âQUENTE** : Apr√®s cr√©ation de nouveaux Use Cases, l'application ne d√©marre plus avec :

```
[Nest] ERROR [Bootstrap] UnknownDependenciesException [Error]:
Nest can't resolve dependencies of the AppointmentController
(GetAvailableSlotsUseCase, BookAppointmentUseCase, ?, GetAppointmentByIdUseCase, UpdateAppointmentUseCase, CancelAppointmentUseCase).
Please make sure that the argument "ListAppointmentsUseCase" at index [2] is available in the PresentationModule context.
```

#### **üîç DIAGNOSTIC RAPIDE**

1. **Identifier le Use Case manquant** : Dans l'erreur ci-dessus, c'est `ListAppointmentsUseCase`
2. **V√©rifier le constructeur du Controller** : Le Use Case est inject√© mais pas enregistr√©
3. **V√©rifier le PresentationModule** : Le provider manque dans la configuration

#### **‚úÖ SOLUTION OBLIGATOIRE**

**√âtape 1 : V√©rifier les imports dans PresentationModule**

```typescript
// ‚ùå MANQUANT - Import du Use Case
import { ListAppointmentsUseCase } from '../../application/use-cases/appointments/list-appointments.use-case';
import { GetAppointmentByIdUseCase } from '../../application/use-cases/appointments/get-appointment-by-id.use-case';
import { UpdateAppointmentUseCase } from '../../application/use-cases/appointments/update-appointment.use-case';
import { CancelAppointmentUseCase } from '../../application/use-cases/appointments/cancel-appointment.use-case';
```

**√âtape 2 : Ajouter les providers dans PresentationModule**

```typescript
// ‚úÖ CORRECT - Providers obligatoires pour nouveaux Use Cases
{
  provide: TOKENS.LIST_APPOINTMENTS_USE_CASE,
  useFactory: (appointmentRepository: AppointmentRepository) =>
    new ListAppointmentsUseCase(appointmentRepository),
  inject: [TOKENS.APPOINTMENT_REPOSITORY],
},
{
  provide: TOKENS.GET_APPOINTMENT_BY_ID_USE_CASE,
  useFactory: (appointmentRepository: AppointmentRepository) =>
    new GetAppointmentByIdUseCase(appointmentRepository),
  inject: [TOKENS.APPOINTMENT_REPOSITORY],
},
{
  provide: TOKENS.UPDATE_APPOINTMENT_USE_CASE,
  useFactory: (appointmentRepository: AppointmentRepository) =>
    new UpdateAppointmentUseCase(appointmentRepository),
  inject: [TOKENS.APPOINTMENT_REPOSITORY],
},
{
  provide: TOKENS.CANCEL_APPOINTMENT_USE_CASE,
  useFactory: (appointmentRepository: AppointmentRepository) =>
    new CancelAppointmentUseCase(appointmentRepository),
  inject: [TOKENS.APPOINTMENT_REPOSITORY],
},
```

#### **üìã PATTERN STANDARDIS√â POUR NOUVEAUX USE CASES**

**Workflow obligatoire √† CHAQUE cr√©ation de Use Case :**

1. **Cr√©er le Use Case** dans `/application/use-cases/{domain}/`
2. **Ajouter le token** dans `injection-tokens.ts`
3. **Importer le Use Case** dans `PresentationModule`
4. **Ajouter le provider** avec `useFactory` et `inject`
5. **Injecter dans le Controller** avec `@Inject(TOKENS.XXX_USE_CASE)`
6. **Tester le d√©marrage** : `npm run start:dev`

#### **üö´ ERREURS √Ä √âVITER**

- ‚ùå **Oublier d'ajouter le provider** apr√®s cr√©ation du Use Case
- ‚ùå **Token manquant** dans injection-tokens.ts
- ‚ùå **Import manquant** du Use Case dans le module
- ‚ùå **Mauvaise configuration** du useFactory/inject
- ‚ùå **Typo dans le nom** du token ou du Use Case

#### **‚úÖ CHECKLIST OBLIGATOIRE**

- [ ] ‚úÖ **Use Case cr√©√©** dans le bon dossier
- [ ] ‚úÖ **Token ajout√©** dans injection-tokens.ts
- [ ] ‚úÖ **Import ajout√©** dans PresentationModule
- [ ] ‚úÖ **Provider configur√©** avec useFactory
- [ ] ‚úÖ **Injection dans Controller** avec @Inject
- [ ] ‚úÖ **Application d√©marre** sans erreur
- [ ] ‚úÖ **Tests passent** apr√®s ajout

\*_Cette documentation √©vitera 90% des erreurs d'injection de d√©pendances lors de l'ajout de nouveaux Use Cases run lint src/presentation/controllers/ 2>&1 | grep -E .controller.ts | head -10_

## üéØ **R√àGLES IMPORTS OBLIGATOIRES - ALIAS TYPESCRIPT**

### üö® **R√àGLE CRITIQUE NON-N√âGOCIABLE : UTILISER EXCLUSIVEMENT LES ALIAS D'IMPORT**

**‚ö†Ô∏è INTERDICTION ABSOLUE** : Utiliser des chemins relatifs dans les imports. TOUJOURS utiliser les alias TypeScript configur√©s dans `tsconfig.json`.

#### **‚úÖ ALIAS CONFIGUR√âS OBLIGATOIRES**

```typescript
// ‚úÖ OBLIGATOIRE - Utiliser TOUJOURS les alias d√©finis
import { User } from '@domain/entities/user.entity';
import { CreateUserUseCase } from '@application/use-cases/users/create-user.use-case';
import { TypeOrmUserRepository } from '@infrastructure/database/sql/postgresql/repositories/typeorm-user.repository';
import { UserController } from '@presentation/controllers/user.controller';
import { Logger } from '@application/ports/logger.port';
import { validateId } from '@shared/utils/validation.utils';

// ‚ùå STRICTEMENT INTERDIT - Chemins relatifs
import { User } from '../../../domain/entities/user.entity';
import { CreateUserUseCase } from '../../application/use-cases/users/create-user.use-case';
import { TypeOrmUserRepository } from './repositories/typeorm-user.repository';
import { Logger } from '../ports/logger.port';
import { validateId } from '../../../../shared/utils/validation.utils';
```

#### **üìã MAPPING D'ALIAS COMPLET**

```typescript
// Configuration tsconfig.json - R√âF√âRENCE
"paths": {
  "@domain/*": ["src/domain/*"],
  "@application/*": ["src/application/*"],
  "@infrastructure/*": ["src/infrastructure/*"],
  "@presentation/*": ["src/presentation/*"],
  "@shared/*": ["src/shared/*"]
}
```

#### **üéØ EXEMPLES CONCRETS PAR COUCHE**

```typescript
// üèõÔ∏è DOMAIN LAYER
import { User } from '@domain/entities/user.entity';
import { Email } from '@domain/value-objects/email.value-object';
import { IUserRepository } from '@domain/repositories/user.repository';
import { UserValidationError } from '@domain/exceptions/user.exceptions';
import { UserService } from '@domain/services/user.service';

// üèóÔ∏è APPLICATION LAYER
import { CreateUserUseCase } from '@application/use-cases/users/create-user.use-case';
import { Logger } from '@application/ports/logger.port';
import { I18nService } from '@application/ports/i18n.port';
import { IAuditService } from '@application/ports/audit.port';
import { UserCacheService } from '@application/services/user-cache.service';

// üîß INFRASTRUCTURE LAYER
import { TypeOrmUserRepository } from '@infrastructure/database/sql/postgresql/repositories/typeorm-user.repository';
import { UserOrmEntity } from '@infrastructure/database/sql/postgresql/entities/user-orm.entity';
import { UserOrmMapper } from '@infrastructure/mappers/user-orm.mapper';
import { DatabaseModule } from '@infrastructure/database/database.module';
import { RedisService } from '@infrastructure/cache/redis.service';

// üé® PRESENTATION LAYER
import { UserController } from '@presentation/controllers/user.controller';
import { CreateUserDto } from '@presentation/dtos/users/create-user.dto';
import { UserMapper } from '@presentation/mappers/user.mapper';
import { JwtAuthGuard } from '@presentation/security/auth.guard';
import { GetUser } from '@presentation/security/decorators/get-user.decorator';

// üîó SHARED LAYER
import { UserRole } from '@shared/enums/user-role.enum';
import { generateId } from '@shared/utils/id.utils';
import { validateEmail } from '@shared/utils/validation.utils';
import { BusinessConstants } from '@shared/constants/business.constants';
import { ApiResponse } from '@shared/types/api.types';
```

#### **üö´ VIOLATIONS STRICTEMENT INTERDITES**

- ‚ùå **JAMAIS** de `../../../domain/entities/user.entity`
- ‚ùå **JAMAIS** de `../../application/use-cases/users/create-user.use-case`
- ‚ùå **JAMAIS** de `./repositories/typeorm-user.repository`
- ‚ùå **JAMAIS** de chemins relatifs dans AUCUN import
- ‚ùå **JAMAIS** m√©langer alias et chemins relatifs dans le m√™me fichier

#### **‚úÖ AVANTAGES DES ALIAS**

1. **üßπ Lisibilit√©** : Code plus propre et compr√©hensible
2. **üîß Maintenabilit√©** : Refactoring facilit√©
3. **üöÄ Performance** : R√©solution d'imports optimis√©e
4. **üìÅ Organisation** : Structure claire du projet
5. **üß™ Testabilit√©** : Mocking et stubbing simplifi√©s
6. **üë• Collaboration** : Standards √©quipe respect√©s

#### **üîç D√âTECTION DES VIOLATIONS**

```bash
# V√©rifier les imports relatifs interdits
grep -r "\.\./\.\./\.\." src/
# R√âSULTAT ATTENDU : Aucun r√©sultat (0 ligne)

# V√©rifier les imports relatifs courts interdits
grep -r "import.*\.\./" src/
# R√âSULTAT ATTENDU : Aucun r√©sultat (0 ligne)

# V√©rifier l'utilisation correcte des alias
grep -r "import.*@domain\|@application\|@infrastructure\|@presentation\|@shared" src/ | head -10
# R√âSULTAT ATTENDU : Nombreux imports avec alias
```

#### **üìã CHECKLIST OBLIGATOIRE AVANT COMMIT**

- [ ] ‚úÖ **Tous les imports utilisent les alias** `@domain/*`, `@application/*`, etc.
- [ ] ‚úÖ **Aucun chemin relatif** `../` dans les imports
- [ ] ‚úÖ **Tests passent** avec les nouveaux imports
- [ ] ‚úÖ **Build compile** sans erreur de r√©solution de modules
- [ ] ‚úÖ **ESLint/TypeScript** ne signalent aucune erreur d'import
- [ ] ‚úÖ **IDE reconna√Æt** correctement tous les imports
- [ ] ‚úÖ **Auto-complete** fonctionne avec les alias
- [ ] ‚úÖ **Refactoring safe** : renommage pr√©serv√©

#### **üõ†Ô∏è CONFIGURATION IDE RECOMMAND√âE**

```json
// .vscode/settings.json
{
  "typescript.preferences.includePackageJsonAutoImports": "on",
  "typescript.suggest.autoImports": true,
  "typescript.preferences.importModuleSpecifier": "shortest",
  "typescript.suggest.includeAutomaticOptionalChainCompletions": true
}
```

#### **üö® SANCTIONS POUR NON-RESPECT**

Le non-respect de cette r√®gle entra√Æne :

- **Rejet automatique** du commit par Husky
- **Blocage de la CI/CD**
- **Review obligatoire** et refactoring imm√©diat
- **Formation suppl√©mentaire** sur les bonnes pratiques TypeScript

**Cette r√®gle garantit un code professionnel, maintenable et respectueux des standards TypeScript !**

## üóÑÔ∏è **R√àGLE CRITIQUE : MIGRATIONS TYPEORM ET DONN√âES EXISTANTES**

### üéØ **R√àGLE FONDAMENTALE NON-N√âGOCIABLE : PR√âSERVER LES DONN√âES EXISTANTES**

**‚ö†Ô∏è R√àGLE CRITIQUE** : Toute migration TypeORM DOIT imp√©rativement tenir compte des donn√©es d√©j√† pr√©sentes en base de donn√©es. Cette r√®gle est **NON-N√âGOCIABLE** pour √©viter la corruption de donn√©es et les pannes en production.

#### **üìã PRINCIPE FONDAMENTAL : SAFETY-FIRST MIGRATIONS**

**TOUJOURS se demander avant chaque migration :**

1. **Y a-t-il d√©j√† des donn√©es** dans cette table ?
2. **Comment pr√©server** l'int√©grit√© des donn√©es existantes ?
3. **Les contraintes ajout√©es** sont-elles compatibles avec les donn√©es actuelles ?
4. **Les colonnes supprim√©es** contiennent-elles des donn√©es critiques ?

#### **‚úÖ PATTERNS OBLIGATOIRES SELON LE TYPE DE MIGRATION**

##### **üÜï AJOUT DE COLONNE - Gestion des Valeurs par D√©faut**

```typescript
// ‚úÖ OBLIGATOIRE - Colonne nullable ou avec valeur par d√©faut
export class AddPricingConfigToServices implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ CORRECT - V√©rifier l'existence avant ajout
    const columnExists = await queryRunner.hasColumn(
      `${schema}.services`,
      'pricing_config',
    );

    if (!columnExists) {
      // ‚úÖ CORRECT - Colonne avec DEFAULT pour donn√©es existantes
      await queryRunner.query(`
        ALTER TABLE "${schema}"."services"
        ADD COLUMN "pricing_config" jsonb 
        DEFAULT '{"type":"FIXED","basePrice":{"amount":0,"currency":"EUR"}}'::jsonb
      `);

      // ‚úÖ CORRECT - Mettre √† jour les donn√©es existantes si n√©cessaire
      await queryRunner.query(`
        UPDATE "${schema}"."services"
        SET "pricing_config" = '{"type":"FIXED","basePrice":{"amount":50,"currency":"EUR"}}'::jsonb
        WHERE "pricing_config" IS NULL AND "is_active" = true
      `);
    }
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ CORRECT - V√©rifier avant suppression
    const columnExists = await queryRunner.hasColumn(
      `${schema}.services`,
      'pricing_config',
    );

    if (columnExists) {
      // ‚ö†Ô∏è ATTENTION - Sauvegarder les donn√©es critiques avant suppression
      await queryRunner.query(`
        -- Optionnel : Sauvegarder les donn√©es dans une table temporaire
        CREATE TABLE IF NOT EXISTS "${schema}"."services_pricing_backup" AS
        SELECT id, pricing_config FROM "${schema}"."services" 
        WHERE pricing_config IS NOT NULL
      `);

      await queryRunner.query(`
        ALTER TABLE "${schema}"."services" DROP COLUMN IF EXISTS "pricing_config"
      `);
    }
  }

  private getSchemaName(): string {
    return process.env.DB_SCHEMA || 'public';
  }
}
```

##### **üîß MODIFICATION DE COLONNE - Gestion des Types et Contraintes**

```typescript
// ‚úÖ OBLIGATOIRE - Transformation s√©curis√©e des donn√©es
export class UpdateStatusEnumInServices implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ √âTAPE 1 - V√©rifier les donn√©es existantes
    const existingData = await queryRunner.query(`
      SELECT DISTINCT status FROM "${schema}"."services"
    `);

    console.log('Statuts existants avant migration:', existingData);

    // ‚úÖ √âTAPE 2 - Ajouter une colonne temporaire avec nouveau type
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services"
      ADD COLUMN "status_new" VARCHAR(20)
    `);

    // ‚úÖ √âTAPE 3 - Migrer les donn√©es avec mapping appropri√©
    await queryRunner.query(`
      UPDATE "${schema}"."services"
      SET "status_new" = CASE
        WHEN status = 'active' THEN 'ACTIVE'
        WHEN status = 'inactive' THEN 'INACTIVE'
        WHEN status = 'draft' THEN 'DRAFT'
        ELSE 'DRAFT' -- Valeur par d√©faut pour donn√©es inconnues
      END
    `);

    // ‚úÖ √âTAPE 4 - Supprimer ancienne colonne et renommer
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services" DROP COLUMN "status"
    `);

    await queryRunner.query(`
      ALTER TABLE "${schema}"."services" 
      RENAME COLUMN "status_new" TO "status"
    `);

    // ‚úÖ √âTAPE 5 - Ajouter contraintes apr√®s transformation
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services"
      ALTER COLUMN "status" SET NOT NULL
    `);
  }

  private getSchemaName(): string {
    return process.env.DB_SCHEMA || 'public';
  }
}
```

##### **üóëÔ∏è SUPPRESSION DE COLONNE - Sauvegarde Obligatoire**

```typescript
// ‚úÖ OBLIGATOIRE - Sauvegarde avant suppression
export class RemoveDeprecatedColumnsFromServices implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ √âTAPE 1 - V√©rifier s'il y a des donn√©es dans la colonne
    const dataCount = await queryRunner.query(`
      SELECT COUNT(*) as count FROM "${schema}"."services" 
      WHERE "deprecated_field" IS NOT NULL
    `);

    if (dataCount[0]?.count > 0) {
      // ‚úÖ √âTAPE 2 - Cr√©er table de sauvegarde
      await queryRunner.query(`
        CREATE TABLE "${schema}"."services_deprecated_backup" AS
        SELECT id, deprecated_field, created_at
        FROM "${schema}"."services"
        WHERE deprecated_field IS NOT NULL
      `);

      console.log(
        `Sauvegarde de ${dataCount[0].count} enregistrements dans services_deprecated_backup`,
      );
    }

    // ‚úÖ √âTAPE 3 - Supprimer la colonne
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services" DROP COLUMN IF EXISTS "deprecated_field"
    `);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    const schema = this.getSchemaName();

    // ‚úÖ √âTAPE 1 - Recr√©er la colonne
    await queryRunner.query(`
      ALTER TABLE "${schema}"."services"
      ADD COLUMN "deprecated_field" VARCHAR(255)
    `);

    // ‚úÖ √âTAPE 2 - Restaurer les donn√©es depuis la sauvegarde
    const backupExists = await queryRunner.hasTable(
      `${schema}.services_deprecated_backup`,
    );

    if (backupExists) {
      await queryRunner.query(`
        UPDATE "${schema}"."services" 
        SET "deprecated_field" = backup."deprecated_field"
        FROM "${schema}"."services_deprecated_backup" backup
        WHERE "${schema}"."services".id = backup.id
      `);
    }
  }

  private getSchemaName(): string {
    return process.env.DB_SCHEMA || 'public';
  }
}
```

#### **üö® WORKFLOW OBLIGATOIRE AVANT CHAQUE MIGRATION**

##### **1Ô∏è‚É£ AUDIT DES DONN√âES EXISTANTES (OBLIGATOIRE)**

```bash
# ‚úÖ OBLIGATOIRE - Se connecter √† la base et analyser les donn√©es
docker compose exec postgres-dev psql -U postgres -d appointment_system

-- V√©rifier la structure actuelle
\dt+ schema_name.*

-- Analyser les donn√©es dans la table concern√©e
SELECT COUNT(*), column_name FROM table_name GROUP BY column_name;
SELECT DISTINCT column_name FROM table_name;
SELECT * FROM table_name LIMIT 10;
```

##### **2Ô∏è‚É£ PLAN DE MIGRATION S√âCURIS√â**

```typescript
// ‚úÖ OBLIGATOIRE - Documenter le plan dans la migration
export class ExampleMigration implements MigrationInterface {
  name = 'ExampleMigration';

  /**
   * PLAN DE MIGRATION S√âCURIS√â
   *
   * üéØ OBJECTIF : [D√©crire l'objectif de la migration]
   *
   * üìä DONN√âES EXISTANTES :
   * - Table "services" contient 150 enregistrements
   * - Colonne "status" : 120 'active', 25 'inactive', 5 'draft'
   * - Aucune valeur NULL dans "status"
   *
   * üõ°Ô∏è MESURES DE S√âCURIT√â :
   * - V√©rification existence colonne avant modification
   * - Sauvegarde donn√©es critiques dans table temporaire
   * - Transformation progressive avec mapping explicite
   * - Rollback complet possible via m√©thode down()
   *
   * ‚ö†Ô∏è RISQUES IDENTIFI√âS :
   * - Perte de donn√©es si mapping incorrect
   * - Contraintes NOT NULL sur donn√©es existantes
   * - Temps d'ex√©cution sur tables volumineuses
   *
   * ‚úÖ TESTS EFFECTU√âS :
   * - Migration test√©e sur copie de base de d√©veloppement
   * - Rollback v√©rifi√© et fonctionnel
   * - Performances acceptables (<5 secondes)
   */
}
```

##### **3Ô∏è‚É£ TESTS OBLIGATOIRES EN D√âVELOPPEMENT**

```bash
# ‚úÖ WORKFLOW OBLIGATOIRE - Tester la migration
# 1. Sauvegarder la base actuelle
docker compose exec postgres-dev pg_dump -U postgres appointment_system > backup_pre_migration.sql

# 2. Appliquer la migration
docker compose exec app npm run migration:run

# 3. V√©rifier les donn√©es apr√®s migration
docker compose exec postgres-dev psql -U postgres -d appointment_system -c "SELECT COUNT(*) FROM services;"

# 4. Tester le rollback
docker compose exec app npm run migration:revert

# 5. V√©rifier que les donn√©es sont restaur√©es
docker compose exec postgres-dev psql -U postgres -d appointment_system -c "SELECT COUNT(*) FROM services;"

# 6. Re-appliquer si le test de rollback r√©ussit
docker compose exec app npm run migration:run
```

#### **‚ùå INTERDICTIONS ABSOLUES - MIGRATIONS DESTRUCTRICES**

- ‚ùå **JAMAIS** `DROP COLUMN` sans sauvegarde des donn√©es
- ‚ùå **JAMAIS** `ALTER COLUMN ... NOT NULL` sans v√©rifier les donn√©es existantes
- ‚ùå **JAMAIS** `DROP TABLE` sans export complet des donn√©es
- ‚ùå **JAMAIS** de migration sans plan de rollback test√©
- ‚ùå **JAMAIS** de transformation de type destructrice
- ‚ùå **JAMAIS** de migration sans v√©rification pr√©alable des donn√©es
- ‚ùå **JAMAIS** ignorer les warnings sur les contraintes

#### **üéØ CHECKLIST OBLIGATOIRE POUR CHAQUE MIGRATION**

- [ ] ‚úÖ **Analyse des donn√©es existantes** effectu√©e
- [ ] ‚úÖ **Plan de migration** document√© dans le fichier
- [ ] ‚úÖ **V√©rifications d'existence** avant modifications
- [ ] ‚úÖ **Valeurs par d√©faut** appropri√©es pour nouvelles colonnes
- [ ] ‚úÖ **Sauvegarde automatique** des donn√©es critiques
- [ ] ‚úÖ **Transformation progressive** pour modifications de type
- [ ] ‚úÖ **M√©thode down()** compl√®te et test√©e
- [ ] ‚úÖ **Tests de migration/rollback** en d√©veloppement
- [ ] ‚úÖ **Performance acceptable** sur donn√©es volumineuses
- [ ] ‚úÖ **Documentation des risques** identifi√©s et mitig√©s

#### **üìä EXEMPLES CONCRETS PAR CAS D'USAGE**

##### **Cas 1 : Ajout de colonne obligatoire sur table peupl√©e**

```sql
-- ‚ùå INTERDIT - Causera des erreurs sur donn√©es existantes
ALTER TABLE services ADD COLUMN required_field VARCHAR(50) NOT NULL;

-- ‚úÖ CORRECT - Progression en 3 √©tapes
-- √âtape 1 : Ajouter colonne nullable avec d√©faut
ALTER TABLE services ADD COLUMN required_field VARCHAR(50) DEFAULT 'DEFAULT_VALUE';

-- √âtape 2 : Mettre √† jour les donn√©es existantes
UPDATE services SET required_field = 'APPROPRIATE_VALUE' WHERE required_field IS NULL;

-- √âtape 3 : Ajouter contrainte NOT NULL
ALTER TABLE services ALTER COLUMN required_field SET NOT NULL;
```

##### **Cas 2 : Changement de type avec donn√©es existantes**

```sql
-- ‚ùå INTERDIT - Perte de donn√©es garantie
ALTER TABLE services ALTER COLUMN price TYPE INTEGER;

-- ‚úÖ CORRECT - Colonne temporaire et migration
ALTER TABLE services ADD COLUMN price_new INTEGER;
UPDATE services SET price_new = CAST(price AS INTEGER) WHERE price ~ '^[0-9]+$';
UPDATE services SET price_new = 0 WHERE price_new IS NULL; -- D√©faut s√©curis√©
ALTER TABLE services DROP COLUMN price;
ALTER TABLE services RENAME COLUMN price_new TO price;
```

#### **üö® SANCTIONS POUR NON-RESPECT**

Le non-respect de cette r√®gle entra√Æne :

- **Blocage imm√©diat** de la migration en production
- **Corruption potentielle** des donn√©es critiques
- **Rollback d'urgence** et investigation compl√®te
- **Review obligatoire** de toutes les migrations futures
- **Formation suppl√©mentaire** sur les bonnes pratiques

**Cette r√®gle est CRITIQUE pour la s√©curit√© et l'int√©grit√© des donn√©es !**
