/**
 * ðŸ§ª TESTS - Password Reset Code Repository Interface
 *
 * Tests TDD pour l'interface repository IPasswordResetCodeRepository
 * Test de contrat d'interface avec mock
 */

import { PasswordResetCode } from '../../../domain/entities/password-reset-code.entity';
import { IPasswordResetCodeRepository } from '../../../domain/repositories/password-reset-code.repository';

// Mock repository pour tester le contrat de l'interface rÃ©elle
class MockPasswordResetCodeRepository implements IPasswordResetCodeRepository {
  private codes: PasswordResetCode[] = [];

  async save(code: PasswordResetCode): Promise<void> {
    const existingIndex = this.codes.findIndex(c => c.id === code.id);
    if (existingIndex >= 0) {
      this.codes[existingIndex] = code;
    } else {
      this.codes.push(code);
    }
  }

  async findByCode(code: string): Promise<PasswordResetCode | null> {
    return this.codes.find(c => c.code === code) || null;
  }

  async findValidCodesByUserId(userId: string): Promise<PasswordResetCode[]> {
    return this.codes.filter(c =>
      c.userId === userId && c.isValid
    );
  }

  async invalidateUserCodes(userId: string): Promise<void> {
    this.codes.forEach(c => {
      if (c.userId === userId && c.isValid) {
        c.markAsUsed();
      }
    });
  }

  async markAsUsed(code: string): Promise<void> {
    const resetCode = await this.findByCode(code);
    if (resetCode) {
      resetCode.markAsUsed();
    }
  }

  async deleteExpiredCodes(): Promise<number> {
    const initialCount = this.codes.length;
    this.codes = this.codes.filter(c => !c.isExpired);
    return initialCount - this.codes.length;
  }

  async deleteUserCodes(userId: string): Promise<void> {
    this.codes = this.codes.filter(c => c.userId !== userId);
  }

  async isCodeValid(code: string): Promise<boolean> {
    const resetCode = await this.findByCode(code);
    return resetCode ? resetCode.isValid : false;
  }
}

describe('IPasswordResetCodeRepository Contract', () => {
  let repository: IPasswordResetCodeRepository;
  let testCode: PasswordResetCode;
  let testUserId: string;

  beforeEach(() => {
    repository = new MockPasswordResetCodeRepository();
    testUserId = 'user-123';
    testCode = PasswordResetCode.create(testUserId);
  });

  describe('save', () => {
    it('should save a new password reset code', async () => {
      // When
      await repository.save(testCode);

      // Then
      const found = await repository.findByCode(testCode.code);
      expect(found).not.toBeNull();
      expect(found?.code).toBe(testCode.code);
      expect(found?.userId).toBe(testUserId);
    });

    it('should update existing password reset code', async () => {
      // Given
      await repository.save(testCode);
      testCode.markAsUsed();

      // When
      await repository.save(testCode);

      // Then
      const found = await repository.findByCode(testCode.code);
      expect(found?.isUsed).toBe(true);
    });
  });

  describe('findByCode', () => {
    it('should find existing code', async () => {
      // Given
      await repository.save(testCode);

      // When
      const found = await repository.findByCode(testCode.code);

      // Then
      expect(found).not.toBeNull();
      expect(found?.code).toBe(testCode.code);
    });

    it('should return null for non-existent code', async () => {
      // When
      const found = await repository.findByCode('9999');

      // Then
      expect(found).toBeNull();
    });
  });

  describe('findValidCodesByUserId', () => {
    it('should find valid codes for user', async () => {
      // Given
      const code1 = PasswordResetCode.create(testUserId);
      const code2 = PasswordResetCode.create(testUserId);
      await repository.save(code1);
      await repository.save(code2);

      // When
      const codes = await repository.findValidCodesByUserId(testUserId);

      // Then
      expect(codes).toHaveLength(2);
      expect(codes.every(c => c.userId === testUserId)).toBe(true);
      expect(codes.every(c => c.isValid)).toBe(true);
    });

    it('should not return used codes', async () => {
      // Given
      const usedCode = PasswordResetCode.create(testUserId);
      const validCode = PasswordResetCode.create(testUserId);
      usedCode.markAsUsed();

      await repository.save(usedCode);
      await repository.save(validCode);

      // When
      const codes = await repository.findValidCodesByUserId(testUserId);

      // Then
      expect(codes).toHaveLength(1);
      expect(codes[0].code).toBe(validCode.code);
    });

    it('should not return expired codes', async () => {
      // Given
      const expiredCode = PasswordResetCode.create(testUserId);
      const validCode = PasswordResetCode.create(testUserId);
      (expiredCode as any)._expiresAt = new Date(Date.now() - 1000); // Expired

      await repository.save(expiredCode);
      await repository.save(validCode);

      // When
      const codes = await repository.findValidCodesByUserId(testUserId);

      // Then
      expect(codes).toHaveLength(1);
      expect(codes[0].code).toBe(validCode.code);
    });

    it('should return empty array for non-existent user', async () => {
      // When
      const codes = await repository.findValidCodesByUserId('non-existent');

      // Then
      expect(codes).toHaveLength(0);
    });
  });

  describe('invalidateUserCodes', () => {
    it('should invalidate all valid codes for user', async () => {
      // Given
      const code1 = PasswordResetCode.create(testUserId);
      const code2 = PasswordResetCode.create(testUserId);
      await repository.save(code1);
      await repository.save(code2);

      // When
      await repository.invalidateUserCodes(testUserId);

      // Then
      const codes = await repository.findValidCodesByUserId(testUserId);
      expect(codes).toHaveLength(0);
    });

    it('should not affect other users codes', async () => {
      // Given
      const userCode = PasswordResetCode.create(testUserId);
      const otherUserCode = PasswordResetCode.create('other-user');
      await repository.save(userCode);
      await repository.save(otherUserCode);

      // When
      await repository.invalidateUserCodes(testUserId);

      // Then
      const userCodes = await repository.findValidCodesByUserId(testUserId);
      const otherCodes = await repository.findValidCodesByUserId('other-user');

      expect(userCodes).toHaveLength(0);
      expect(otherCodes).toHaveLength(1);
    });
  });

  describe('markAsUsed', () => {
    it('should mark code as used', async () => {
      // Given
      await repository.save(testCode);

      // When
      await repository.markAsUsed(testCode.code);

      // Then
      const found = await repository.findByCode(testCode.code);
      expect(found?.isUsed).toBe(true);
    });

    it('should handle non-existent code gracefully', async () => {
      // When & Then
      await expect(repository.markAsUsed('9999')).resolves.not.toThrow();
    });
  });

  describe('deleteExpiredCodes', () => {
    it('should delete expired codes and return count', async () => {
      // Given
      const validCode = PasswordResetCode.create(testUserId);
      const expiredCode1 = PasswordResetCode.create('user-456');
      const expiredCode2 = PasswordResetCode.create('user-789');
      (expiredCode1 as any)._expiresAt = new Date(Date.now() - 1000);
      (expiredCode2 as any)._expiresAt = new Date(Date.now() - 1000);

      await repository.save(validCode);
      await repository.save(expiredCode1);
      await repository.save(expiredCode2);

      // When
      const deletedCount = await repository.deleteExpiredCodes();

      // Then
      expect(deletedCount).toBe(2);
      const validFound = await repository.findByCode(validCode.code);
      const expired1Found = await repository.findByCode(expiredCode1.code);
      const expired2Found = await repository.findByCode(expiredCode2.code);

      expect(validFound).not.toBeNull();
      expect(expired1Found).toBeNull();
      expect(expired2Found).toBeNull();
    });

    it('should return 0 when no expired codes', async () => {
      // Given
      const validCode = PasswordResetCode.create(testUserId);
      await repository.save(validCode);

      // When
      const deletedCount = await repository.deleteExpiredCodes();

      // Then
      expect(deletedCount).toBe(0);
    });
  });

  describe('deleteUserCodes', () => {
    it('should delete all codes for user', async () => {
      // Given
      const code1 = PasswordResetCode.create(testUserId);
      const code2 = PasswordResetCode.create(testUserId);
      const otherUserCode = PasswordResetCode.create('other-user');

      await repository.save(code1);
      await repository.save(code2);
      await repository.save(otherUserCode);

      // When
      await repository.deleteUserCodes(testUserId);

      // Then
      const found1 = await repository.findByCode(code1.code);
      const found2 = await repository.findByCode(code2.code);
      const otherFound = await repository.findByCode(otherUserCode.code);

      expect(found1).toBeNull();
      expect(found2).toBeNull();
      expect(otherFound).not.toBeNull();
    });
  });

  describe('isCodeValid', () => {
    it('should return true for valid code', async () => {
      // Given
      await repository.save(testCode);

      // When
      const isValid = await repository.isCodeValid(testCode.code);

      // Then
      expect(isValid).toBe(true);
    });

    it('should return false for used code', async () => {
      // Given
      testCode.markAsUsed();
      await repository.save(testCode);

      // When
      const isValid = await repository.isCodeValid(testCode.code);

      // Then
      expect(isValid).toBe(false);
    });

    it('should return false for expired code', async () => {
      // Given
      (testCode as any)._expiresAt = new Date(Date.now() - 1000);
      await repository.save(testCode);

      // When
      const isValid = await repository.isCodeValid(testCode.code);

      // Then
      expect(isValid).toBe(false);
    });

    it('should return false for non-existent code', async () => {
      // When
      const isValid = await repository.isCodeValid('9999');

      // Then
      expect(isValid).toBe(false);
    });
  });
});
