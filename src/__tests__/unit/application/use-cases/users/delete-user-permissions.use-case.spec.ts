/**
 * üß™ TDD TESTS - Delete User Use Case Permissions
 *
 * Tests RED-GREEN-REFACTOR pour v√©rifier que les permissions
 * sont correctement appliqu√©es dans DeleteUserUseCase
 *
 * R√àGLE TDD : Tests AVANT impl√©mentation !
 */

import { InsufficientPermissionsError } from "@application/exceptions/auth.exceptions";
import { I18nService } from "@application/ports/i18n.port";
import { Logger } from "@application/ports/logger.port";
import { IPermissionService } from "@application/ports/permission.service.interface";
import {
  DeleteUserRequest,
  DeleteUserUseCase,
} from "@application/use-cases/users/delete-user.use-case";
import { User } from "@domain/entities/user.entity";
import { UserRepository } from "@domain/repositories/user.repository.interface";
import { UserRole } from "@shared/enums/user-role.enum";

describe("üß™ TDD - DeleteUserUseCase Permissions", () => {
  let useCase: DeleteUserUseCase;
  let mockPermissionService: jest.Mocked<IPermissionService>;
  let mockUserRepository: jest.Mocked<UserRepository>;
  let mockLogger: jest.Mocked<Logger>;
  let mockI18n: jest.Mocked<I18nService>;

  beforeEach(() => {
    // Mocks
    mockPermissionService = {
      requirePermission: jest.fn(),
      canActOnRole: jest.fn(),
      canManageUser: jest.fn(),
      hasPermission: jest.fn(),
      getUserRole: jest.fn(),
      hasRole: jest.fn(),
      getUserPermissions: jest.fn(),
      hasBusinessPermission: jest.fn(),
      isSuperAdmin: jest.fn(),
      requireSuperAdminPermission: jest.fn(),
    } as jest.Mocked<IPermissionService>;

    mockUserRepository = {
      findById: jest.fn(),
      save: jest.fn(),
      delete: jest.fn(),
      findByEmail: jest.fn(),
      findAll: jest.fn(),
      exists: jest.fn(),
    } as jest.Mocked<UserRepository>;

    mockLogger = {
      info: jest.fn(),
      error: jest.fn(),
      warn: jest.fn(),
      debug: jest.fn(),
      audit: jest.fn(),
      child: jest.fn().mockReturnThis(),
    } as jest.Mocked<Logger>;

    mockI18n = {
      translate: jest.fn().mockReturnValue("Mock translated message"),
      t: jest.fn().mockReturnValue("Mock translated message"),
      setDefaultLanguage: jest.fn(),
      exists: jest.fn().mockReturnValue(true),
    } as jest.Mocked<I18nService>;

    // ‚úÖ Construction avec ordre correct des param√®tres
    useCase = new DeleteUserUseCase(
      mockUserRepository,
      mockPermissionService, // IPermissionService en 2√®me position
      mockLogger,
      mockI18n,
    );
  });

  describe("üîê Permission Checks - TDD RED Phase", () => {
    it("üö® RED - should call requirePermission before deleting user", async () => {
      // Given
      const request: DeleteUserRequest = {
        requestingUserId: "admin-user-id",
        targetUserId: "target-user-id",
      };

      const mockRequestingUser = {
        id: "admin-user-id",
        email: "admin@example.com",
        role: UserRole.SUPER_ADMIN,
        name: "Admin User",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      const mockTargetUser = {
        id: "target-user-id",
        email: "target@example.com",
        role: UserRole.REGULAR_CLIENT,
        name: "Target User",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      // Mock aussi la v√©rification "not already deleted"
      mockUserRepository.findById
        .mockResolvedValueOnce(mockRequestingUser) // Premier appel pour requesting user
        .mockResolvedValueOnce(mockTargetUser) // Second appel pour target user
        .mockResolvedValueOnce(mockTargetUser); // Troisi√®me appel pour validateNotAlreadyDeleted

      // Mock delete pour √©viter l'erreur
      mockUserRepository.delete.mockResolvedValueOnce(undefined);

      // üö® TDD RED : Cette m√©thode n'est pas encore appel√©e dans le Use Case !
      mockPermissionService.requirePermission.mockResolvedValueOnce(undefined);
      mockPermissionService.canManageUser.mockResolvedValueOnce(true);

      // When & Then - Le test va √©chouer car les permissions ne sont pas v√©rifi√©es
      await useCase.execute(request);

      // üéØ TDD Assertion : Ces v√©rifications vont √©chouer (RED) - ajustons le contexte
      expect(mockPermissionService.requirePermission).toHaveBeenCalledWith(
        "admin-user-id",
        "DELETE_USER",
        {
          targetUserId: "target-user-id",
          targetRole: UserRole.REGULAR_CLIENT, // Ajust√© selon l'impl√©mentation
        },
      );

      expect(mockPermissionService.canManageUser).toHaveBeenCalledWith(
        "admin-user-id",
        "target-user-id",
        // Pas de 3√®me param√®tre selon l'impl√©mentation
      );
    });

    it("üö® RED - should throw InsufficientPermissionsError when user cannot delete", async () => {
      // Given
      const request: DeleteUserRequest = {
        requestingUserId: "low-privilege-user-id",
        targetUserId: "target-user-id",
      };

      const mockRequestingUser = {
        id: "low-privilege-user-id",
        email: "low@example.com",
        role: UserRole.REGULAR_CLIENT,
        name: "Low Privilege User",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      const mockTargetUser = {
        id: "target-user-id",
        email: "target@example.com",
        role: UserRole.PRACTITIONER,
        name: "Target User",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      // Mock les users pour √©viter UserNotFoundError
      mockUserRepository.findById
        .mockResolvedValueOnce(mockRequestingUser)
        .mockResolvedValueOnce(mockTargetUser);

      // üö® TDD RED : Cette exception ne sera pas lanc√©e car les permissions
      // ne sont pas encore v√©rifi√©es dans le Use Case !
      mockPermissionService.requirePermission.mockRejectedValueOnce(
        new InsufficientPermissionsError("DELETE_USER_DENIED"),
      );

      // When & Then - Le test va √©chouer car l'exception n'est pas propag√©e
      await expect(useCase.execute(request)).rejects.toThrow(
        InsufficientPermissionsError,
      );

      expect(mockPermissionService.requirePermission).toHaveBeenCalledWith(
        "low-privilege-user-id",
        "DELETE_USER",
        {
          targetUserId: "target-user-id",
          targetRole: UserRole.PRACTITIONER, // Ajust√© selon l'impl√©mentation
        },
      );
    });

    it("üö® RED - should verify user can manage target user before deletion", async () => {
      // Given
      const request: DeleteUserRequest = {
        requestingUserId: "manager-user-id",
        targetUserId: "subordinate-user-id",
      };

      const mockRequestingUser = {
        id: "manager-user-id",
        email: "manager@example.com",
        role: UserRole.LOCATION_MANAGER,
        name: "Manager User",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      const mockTargetUser = {
        id: "subordinate-user-id",
        email: "subordinate@example.com",
        role: UserRole.PRACTITIONER,
        name: "Subordinate User",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      // Mock les users pour √©viter UserNotFoundError + validateNotAlreadyDeleted
      mockUserRepository.findById
        .mockResolvedValueOnce(mockRequestingUser)
        .mockResolvedValueOnce(mockTargetUser)
        .mockResolvedValueOnce(mockTargetUser); // Pour validateNotAlreadyDeleted

      // Mock delete pour √©viter l'erreur
      mockUserRepository.delete.mockResolvedValueOnce(undefined);

      mockPermissionService.requirePermission.mockResolvedValueOnce(undefined);

      // üö® TDD RED : Cette v√©rification n'est pas encore faite dans le Use Case !
      mockPermissionService.canManageUser.mockResolvedValueOnce(false);

      // When & Then - Le test va √©chouer car canManageUser n'est pas v√©rifi√©
      await expect(useCase.execute(request)).rejects.toThrow(
        InsufficientPermissionsError,
      );

      expect(mockPermissionService.canManageUser).toHaveBeenCalledWith(
        "manager-user-id",
        "subordinate-user-id",
        // Pas de 3√®me param√®tre selon l'impl√©mentation
      );
    });
  });

  describe("üéØ Business Rules - Permission Context", () => {
    it("üö® RED - should pass business context when available", async () => {
      // Given
      const request: DeleteUserRequest = {
        requestingUserId: "business-owner-id",
        targetUserId: "business-staff-id",
      };

      const mockRequestingUser = {
        id: "business-owner-id",
        email: "owner@business.com",
        role: UserRole.BUSINESS_OWNER,
        name: "Business Owner",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      const mockTargetUser = {
        id: "business-staff-id",
        email: "staff@business.com",
        role: UserRole.PRACTITIONER,
        businessId: "business-123", // Context m√©tier
        name: "Business Staff",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      // Mock aussi la v√©rification "not already deleted"
      mockUserRepository.findById
        .mockResolvedValueOnce(mockRequestingUser)
        .mockResolvedValueOnce(mockTargetUser)
        .mockResolvedValueOnce(mockTargetUser); // Pour validateNotAlreadyDeleted

      // Mock delete pour √©viter l'erreur
      mockUserRepository.delete.mockResolvedValueOnce(undefined);

      mockPermissionService.requirePermission.mockResolvedValueOnce(undefined);
      mockPermissionService.canManageUser.mockResolvedValueOnce(true);

      // When
      await useCase.execute(request);

      // Then - V√©rifier que le contexte business est pass√© (ajust√© selon impl√©mentation)
      expect(mockPermissionService.requirePermission).toHaveBeenCalledWith(
        "business-owner-id",
        "DELETE_USER",
        {
          targetUserId: "business-staff-id",
          targetRole: UserRole.PRACTITIONER, // L'impl√©mentation passe targetRole, pas businessId
        },
      );
    });
  });

  describe("üîç Error Cases - Permission Failures", () => {
    it("üö® RED - should log permission denial with context", async () => {
      // Given
      const request: DeleteUserRequest = {
        requestingUserId: "unauthorized-user-id",
        targetUserId: "protected-user-id",
      };

      const mockRequestingUser = {
        id: "unauthorized-user-id",
        email: "unauthorized@example.com",
        role: UserRole.REGULAR_CLIENT,
        name: "Unauthorized User",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      const mockTargetUser = {
        id: "protected-user-id",
        email: "protected@example.com",
        role: UserRole.SUPER_ADMIN,
        name: "Protected User",
        createdAt: new Date(),
        passwordChangeRequired: false,
      } as unknown as User;

      // Mock les users pour √©viter UserNotFoundError
      mockUserRepository.findById
        .mockResolvedValueOnce(mockRequestingUser)
        .mockResolvedValueOnce(mockTargetUser);

      const permissionError = new InsufficientPermissionsError(
        "Cannot delete users with higher privileges",
      );

      mockPermissionService.requirePermission.mockRejectedValueOnce(
        permissionError,
      );

      // When & Then
      await expect(useCase.execute(request)).rejects.toThrow(
        InsufficientPermissionsError,
      );

      // üéØ TDD : V√©rifier que l'erreur est logg√©e avec le contexte appropri√©
      expect(mockLogger.error).toHaveBeenCalledWith(
        "delete_failed",
        expect.any(Error),
        expect.objectContaining({
          operation: "DeleteUser",
          requestingUserId: "unauthorized-user-id",
          targetUserId: "protected-user-id",
        }),
      );
    });
  });
});
