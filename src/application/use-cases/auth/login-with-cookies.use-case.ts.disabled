/**
 * üîê LOGIN USE CASE - avec cookies et session Redis
 *
 * Use Case pour l'authentification utilisateur avec :
 * - Stockage des tokens dans des cookies HttpOnly
 * - Session utilisateur dans Redis avec TTL configurable
 * - Audit logging complet
 */

import { Injectable, Inject } from '@nestjs/common';
import { Response } from 'express';
import { ConfigService } from '@nestjs/config';
import type { IUserRepository } from '../../ports/user.repository.interface';
import type { IAuthTokenService } from '../../ports/auth-token.service.interface';
import type { IUserSessionService } from '../../ports/user-session.port';
import type { ICookieService } from '../../ports/cookie.port';
import type { Logger } from '../../ports/logger.port';
import type { I18nService } from '../../ports/i18n.port';
import type { IPasswordService } from '../../ports/password.service.interface';
import { InvalidCredentialsError } from '../../exceptions/auth.exceptions';
import { Email } from '../../../domain/value-objects/email.vo';
import { AppContextFactory } from '../../../shared/context/app-context';
import { TOKENS } from '../../../shared/constants/injection-tokens';

export interface LoginWithCookiesRequest {
  readonly email: string;
  readonly password: string;
  readonly rememberMe?: boolean;
  readonly ip?: string;
  readonly userAgent?: string;
}

export interface LoginWithCookiesResponse {
  readonly user: {
    readonly id: string;
    readonly email: string;
    readonly name: string;
    readonly role: string;
  };
  readonly message: string;
}

@Injectable()
export class LoginWithCookiesUseCase {
  constructor(
    @Inject(TOKENS.USER_REPOSITORY)
    private readonly userRepository: IUserRepository,
    @Inject(TOKENS.PASSWORD_SERVICE)
    private readonly passwordService: IPasswordService,
    @Inject(TOKENS.AUTH_TOKEN_SERVICE)
    private readonly tokenService: IAuthTokenService,
    @Inject(TOKENS.USER_SESSION_SERVICE)
    private readonly sessionService: IUserSessionService,
    @Inject(TOKENS.COOKIE_SERVICE)
    private readonly cookieService: ICookieService,
    @Inject(TOKENS.PINO_LOGGER)
    private readonly logger: Logger,
    @Inject(TOKENS.I18N_SERVICE)
    private readonly i18n: I18nService,
    private readonly configService: ConfigService,
  ) {}

  async execute(
    request: LoginWithCookiesRequest,
    response: Response,
  ): Promise<LoginWithCookiesResponse> {
    // üìù Contexte d'audit
    const context = AppContextFactory.create()
      .operation('LoginWithCookies')
      .clientInfo(request.email)
      .build();

    this.logger.info(this.i18n.t('operations.auth.login_attempt'), {
      correlationId: context.correlationId,
      operationId: context.operationId,
      email: request.email,
      rememberMe: request.rememberMe,
    });

    try {
      // 1. üîç Rechercher l'utilisateur par email
      const email = Email.create(request.email);
      const user = await this.userRepository.findByEmail(email.value);

      if (!user) {
        this.logger.warn(this.i18n.t('operations.auth.user_not_found'), {
          correlationId: context.correlationId,
          operationId: context.operationId,
          email: request.email,
        });
        throw new InvalidCredentialsError();
      }

      // 2. üîê V√©rifier le mot de passe
      const isPasswordValid = await this.passwordService.verify(
        request.password,
        user.hashedPassword || '',
      );

      if (!isPasswordValid) {
        this.logger.warn(this.i18n.t('operations.auth.invalid_password'), {
          correlationId: context.correlationId,
          operationId: context.operationId,
          userId: user.id,
          email: request.email,
        });
        throw new InvalidCredentialsError();
      }

      // 3. üé´ G√©n√©rer les tokens JWT
      const securityContext = {
        requestId: context.correlationId,
        ip: request.ip || 'unknown',
        userAgent: request.userAgent || 'unknown',
        timestamp: new Date(),
        environment:
          (this.configService.get<string>('NODE_ENV') as
            | 'development'
            | 'staging'
            | 'production') || 'development',
      };

      const authTokensResult = await this.tokenService.generateAuthTokens(
        user,
        securityContext,
        request.rememberMe,
      );

      // 4. üç™ D√©finir les cookies s√©curis√©s
      await this.setAuthCookies(
        response,
        authTokensResult.accessToken,
        authTokensResult.refreshToken,
        request.rememberMe,
      );

      // 5. üë§ Stocker la session utilisateur dans Redis
      await this.sessionService.storeUserSession(user.id, user);

      // 6. üìä Audit de succ√®s
      this.logger.info(this.i18n.t('operations.auth.login_success'), {
        correlationId: context.correlationId,
        operationId: context.operationId,
        userId: user.id,
        email: user.email.value,
      });

      // 7. üì§ R√©ponse
      return {
        user: {
          id: user.id,
          email: user.email.value,
          name: user.name,
          role: user.role,
        },
        message: this.i18n.t('success.auth.login_completed'),
      };
    } catch (error) {
      this.logger.error(
        this.i18n.t('operations.auth.login_failed'),
        error as Error,
        {
          correlationId: context.correlationId,
          operationId: context.operationId,
        },
      );
      throw error;
    }
  }

  /**
   * üç™ D√©finit les cookies d'authentification s√©curis√©s
   */
  private async setAuthCookies(
    response: Response,
    accessToken: string,
    refreshToken: string,
  ): Promise<void> {
    const isProduction =
      this.configService.get<string>('NODE_ENV') === 'production';
    const accessTokenExpiration = this.configService.get<number>(
      'ACCESS_TOKEN_EXPIRATION',
      900,
    ); // 15min
    const refreshTokenExpirationDays = this.configService.get<number>(
      'REFRESH_TOKEN_EXPIRATION_DAYS',
      7,
    );

    const baseOptions = {
      httpOnly: true,
      secure: isProduction,
      sameSite: 'strict' as const,
    };

    // üé´ Cookie Access Token (courte dur√©e)
    this.cookieService.setCookie(response, 'access_token', accessToken, {
      ...baseOptions,
      maxAge: accessTokenExpiration * 1000, // Convert to milliseconds
    });

    // üîÑ Cookie Refresh Token (longue dur√©e ou session)
    const refreshMaxAge = rememberMe
      ? refreshTokenExpirationDays * 24 * 60 * 60 * 1000 // Jours en ms
      : undefined; // Session cookie si pas rememberMe

    this.cookieService.setCookie(response, 'refresh_token', refreshToken, {
      ...baseOptions,
      maxAge: refreshMaxAge,
    });

    this.logger.debug(this.i18n.t('infrastructure.auth.cookies_set'), {
      accessTokenExpiration,
      refreshTokenExpiration: refreshMaxAge
        ? refreshTokenExpirationDays
        : 'session',
      rememberMe,
      secure: isProduction,
    });
  }
}
